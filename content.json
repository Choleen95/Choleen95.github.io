{
  "pages": [
    {
      "title": "",
      "text": "关于我大家好，我是山沉，这是我建的第一个博客。现在是java+微服务路上的行者，希望我们共同上路，一路前行。 我的站点 博客园：山沉 CSDN：山沉 思否：山沉 掘金：山沉",
      "link": "/about/index.html"
    },
    {
      "title": "categories",
      "text": "",
      "link": "/categories/index.html"
    }
  ],
  "posts": [
    {
      "title": "ie浏览器的加载js不了的问题",
      "text": "2020年3月13日工作问题问题：在jsp页面，下有js文件没有加载出来，但是在f12下，刷新就加载出来了。 我打开的网页是360安全浏览器，内核设置为ie8，但是打开网页有一些js文件就是加载不出来，后来查询 得知。在ie8/9模式下，只能打开f12生效console方法。在ie6/7，根本没有这个方法。 解决： 1.直接一点，删除就可以了 2.用代码解决 if(window.console){ //一些console命令 console.info(&quot;gogo&quot;)； }这次的问题发生了，及时的解决，才能更好的锻炼自己。",
      "link": "/2020/03/13/34b1e03.html"
    },
    {
      "title": "Postgresql导出数据字典",
      "text": "这是在工作中，有时会遇到的问题，要求完善数据字典。这里是python导出Postgresql表的字典，仅供参考。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161import psycopg2import xlwtfrom datetime import datetimeimport os def getData(): conn = psycopg2.connect(database='数据库名', user='postgres', password='密码', host='127.0.0.1', port=5432) cur = conn.cursor() query = ''' SELECT d.relname AS relname, obj_description ( relfilenode, 'pg_class' ) AS tablename, attname AS field,CASE typname WHEN '_bpchar' THEN 'char' WHEN '_varchar' THEN 'varchar' WHEN '_date' THEN 'date' WHEN '_float8' THEN 'float8' WHEN '_int4' THEN 'int4' WHEN '_int8' THEN 'int8' WHEN '_interval' THEN 'interval' WHEN '_numeric' THEN 'numeric' WHEN '_float4' THEN 'float4' WHEN '_int2' THEN 'smallint' WHEN '_text' THEN 'text' WHEN '_time' THEN 'time' WHEN '_timestamp' THEN 'timestamp' WHEN '_timestamptz' THEN 'timestamptz' END AS TYPE, CASE typname WHEN '_bpchar' THEN atttypmod - 4 WHEN '_varchar' THEN atttypmod - 4 WHEN '_numeric' THEN ( atttypmod - 4 ) / 65536 ELSE attlen END AS LENGTH, CASE typname WHEN '_numeric' THEN ( atttypmod - 4 ) % 65536 ELSE 0 END AS xs,CASE WHEN b.attnotnull = 't' THEN '不能为空' ELSE'' END AS NOTNULL,CASE WHEN ( SELECT COUNT ( * ) FROM pg_constraint WHERE conrelid = b.attrelid AND conkey [ 1 ]= attnum AND contype = 'p' ) &gt; 0 THEN '主键' ELSE'' END AS zj ,col_description ( b.attrelid, b.attnum ) AS COMMENTFROM pg_stat_user_tables AS A, pg_class AS d, pg_tables AS P, pg_attribute AS b, pg_type AS CWHERE A.relid = b.attrelid AND b.attnum &gt; 0 AND b.atttypid = C.typelem AND substr( typname, 1, 1 ) = '_' AND P.tablename = d.relname AND d.relname = A.relname AND A.relname NOT LIKE'c%' AND A.relname NOT LIKE'S%'ORDER BY A.schemaname, A.relname,attnum ''' cur.execute(query) data = cur.fetchall() conn.commit() cur.close() conn.close() return data def queryDataToExcel(name): data = getData() myExcel = xlwt.Workbook('encoding=utf-8') # 查询二原数据采集量 sheet1 = myExcel.add_sheet(name, cell_overwrite_ok=True) sheet1.col(0).width = 150 * 20 sheet1.col(1).width = 150 * 20 sheet1.col(2).width = 150 * 20 sheet1.col(3).width = 150 * 20 sheet1.col(4).width = 150 * 20 sheet1.col(5).width = 150 * 20 sheet1.col(6).width = 150 * 20 sheet1.col(7).width = 150 * 20 sheet1.col(8).width = 150 * 20 sheet1.col(8).width = 350 * 20 #设置居中 a1 = xlwt.Alignment() a1.horz = 0x02 a1.vert = 0x01 style = xlwt.XFStyle() # 赋值style为XFStyle为初始化样式 style.alignment = a1 today = datetime.today() # 获取当前日期，得到一个datetime对象如：(2019, 7, 2, 23, 12, 23, 424000) today_date = datetime.date(today) # 将获取到的datetime对象仅取日期如：2019-7-2 items = ['数据表', '表名', '字段', '类型', '长度', '小数点', '是否为空', '是否为主键', '注释'] for col in range(len(items)): sheet1.write(0, col, items[col]) # 从data获取第一列数据，[(&quot;xxx&quot;,&quot;xxx&quot;),()] first_col = [] for i in range(len(data)): first_col.append(data[i][0]) print(&quot;first_col:&quot;, first_col) # 去掉重复的列数据，并顺序不变 nFirst_col = list(set(first_col)) nFirst_col.sort(key=first_col.index) print(&quot;nFirst_col:&quot;, nFirst_col) row = 1 for i in nFirst_col: count = first_col.count(i) # 计算重复的元素个数 mergeRow = row + count - 1 # 合并后的上行数， sheet1.write_merge(row, mergeRow, 0, 0, i, style) # 第一列 sheet1.write_merge(row, mergeRow, 1, 1, i, style) row = mergeRow + 1 # 从下一行开始写入 # 获取data[i]中的第二个元素，循环写入 for row in range(len(data)): for col in range(1, len(data[row])): sheet1.write(row + 1, col, data[row][col], style) fileName = name + '_' + str(today_date) + '.xls' rootPath = os.path.dirname(os.path.abspath(_file_))+'\\\\' print(rootPath) flag = os.path.exists(rootPath+fileName) if flag: os.remove(rootPath+fileName) myExcel.save(fileName) else: myExcel.save(fileName) # 以传递的name+当前日期作为excel名称保存 if __name__ == '__main__': print(&quot;这是从postgresql中导出excel的demo----&quot;) queryDataToExcel(&quot;数据表&quot;) 这里我用的是xlwt，没用openpyxl操作",
      "link": "/2020/03/07/5ef69155.html"
    },
    {
      "title": "Hello World",
      "text": "Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment",
      "link": "/2020/03/06/4a17b156.html"
    },
    {
      "title": "hexo+icarus搭建的第一个博客",
      "text": "博客的搭建过程中，才发现自己会的东西挺少。今后会继续学习，持之以恒，参考了的一些资料，总算搭建了一个hexo+icarus实现的博客。 所需内容 github账户一个 nodejs安装(之后在安装hexo等) git for windows 0.申请一个github账户注册账户，完成之后生成一个GitHub的 ID.github.io的仓库。这个在之后上传静态资源，可以作为默认网址访问博客。 1.nodejs安装这里不过多的叙述，或者在网上找资料，普通的安装。 2.hexo+icarus搭建博客&emsp;这里推荐小明同学的博客，丰富的记录了hexo搭建博客的所需事项。当时域名的绑定与配置没有搞清楚，后来配置域名时，才知道在国内注册的域名要备案，后来又去备案，结果没有备案，照下面这样做，也能访问。(最好备案，各个网站的app备案更快.) 3.配置华为云域名 在项目的source目录下建一个没有后缀的文件-CNAME，里面写入www.xxx.xx你的域名。 123hexo cleanhexo generatehexo deploy 只要过2到3分中即可用域名访问了。OK！",
      "link": "/2020/03/07/1ce21b5d.html"
    },
    {
      "title": "nodejs启动服务失败",
      "text": "nodejs启动服务过程中难免遇到一些问题，此次我就遇到了node-sass安装后环境发生变化的问题。 1.第一次提示This usually happens because your environment has changed since running npm install百度说是node-sass安装后环境发生变化。需要重新编译或安装node-sass 解决 1.在项目根路径打开管理员模式的cmd 2 npm rebuild node-sass 2.1 提示Cannot download “https://github.com/sass/node-sass/releases/download/v4.13.1/win32-x64-72_binding.node&quot;: 3.设置淘宝下载 npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ ok,启动node服务成功",
      "link": "/2020/03/07/a395ebd.html"
    },
    {
      "title": "Life/Sql1",
      "text": "title: 分享一个sql查询重复记录date: 2020-03-31 23:04tags:categories: MyLife postgres的查询重复sql记录select bill_code,count(1) from t_fee_agencyfee_bill GROUP BY bill_code HAVING count(*) &gt; 1 group by 根据前面查询的字段来分组的。工作中会用到的。",
      "link": "/2020/03/31/f6d88674.html"
    },
    {
      "title": "Life/吾日三省",
      "text": "吾日三省",
      "link": "/2020/04/29/2f0e45c7.html"
    },
    {
      "title": "今天复工，维护好累",
      "text": "维护今天的工作&emsp;今天是我第一次正式维护工作，深知不易。代码可能没有几行，但大多数是在找前人写代码的漏洞，当然是客户给我们找到的。找寻bug很费劲，还原bug更费劲。我大量的时间在跟客户交流，没有几行代码输出，有很大一部分的原因是眉毛胡子一把抓，没有分清主次，搞得很疲惫。&emsp;提高自己的技术，还是重中之重，没有比自己肚子里有货更重要，今天开始学习松哥的springboot系列教程，希望自己可以得到提高。 如何提高自己&emsp;尽量多学习一点。尽量不气馁。尽量跟进时局。今天学习一点markdown的知识： 123半方大的空白&amp;ensp;或&amp;#8194;全方大的空白&amp;emsp;或&amp;#8195;不断行的空白格&amp;nbsp;或&amp;#160;",
      "link": "/2020/03/16/b2d54f77.html"
    },
    {
      "title": "城市套路深，我想回农村",
      "text": "诡异的3960元那天，我以为是幸运的，还准备去买彩票点赞引来的故事那是8月8号的下午15:00左右，我去龙华的华润万家那边做公交车去办理银行卡，在经过斑马线前，我遇到了一个四川成都的人，他让我给一个店家点赞，说是5G什么活动。我看算是半个老乡，就点赞了，点赞之后他送给我一个耳机。我准备马上过斑马线之前，他说可以抽奖，我说抽奖可以，我点了一下，提示抽到一个平板，我跟他到了实体店，店员跟我说了很多，我只记得他说给一个华为畅享10s **，还说要我在支付宝贷款3960元，分为12期还完。她说这个3960元可以在各个官网买手机抵扣，和一些配件、礼品**全额。 内容详细： ​ 我当时没有理解透，我以为都可以在官网上买一些东西全额，我就付款了。之后在我跟她聊天中发现所谓的手机配件是在他们实体店购买可以，还有就是和他们店有合作的商家罗列的高价商品(很多生活中用不到的、不是必须的)，还有就是小黄xx商城，里面的金币商城，那些东西我都不知道质量如何，怎么敢买。 ​ 这里的坑是：我的3960元，相当于在他门店冲了会员，送一个手机，这个会员有3960积分，可以跟他合作的商家购买东西，这些东西跟正常的有多上涨幅就不知到了，可能有些10倍、有些几倍。那个手机我在华为官网看到的价格是1590元，相当于2380元充了3960积分，这2380元的购买力可以买3个1000多某佳牌子的高压锅，和一些超出市价的生活用品(质量鬼晓得)。 ​ 手机的话，要去官网自己选型号、品牌，然后发给店里的销售，让他给你买，用你会员卡的积分抵掉一些钱。我不放心的是，官网上卖的是正品，而他们销售买来给我的是什么？我不知道，也不放心，万一他给我买的不是官网的产品呢？而且4000元以上才能抵扣1000元。我哪来的消费能力，我后来后悔了，想把这个退掉，但是店家一直不退，我也没有办法。一直说那个销售不容易，还有个男的跟我拿笔计算且说这没多少钱。我一个月可能都存不了3960元，真是不知道说一些什么了，只能以后需要什么了，让这个积分有点作用，可能去买那些高价的东西吧，好j b烦。 下面看这些被欺骗的东西，我是一个深圳小白： 聊天记录： ​ 我要是找朋友来买这东西，我以后还怎么面对他们。 还有这个小黄xx商城中的金币商城，我进里面看了一下，都是一些小商品，里面就只有商品名字+很多图片，又没有说是哪个厂家，怎么让我放心产品质量。。。。 这一次的经历： ​ 1600百元的华为手机+3960积分(店铺会员) == 支付宝还款3960元。 ​ 3960积分 == 可能1000(我自己估的实际价值)元左右的电子商品（如果实体店还承认这个积分） 损失： ​ 若全额可换： ​ 3960 - (1600 + 1000) == 1360元 ​ 若不能换： ​ 3960 - 1600 == 2360元 同学们，请以我为例子，警防这些套路啊。",
      "link": "/2020/08/05/a611db9a.html"
    },
    {
      "title": "迎难而上",
      "text": "###生活本苦，奈何年华我们再物欲横流的今天，静下心来想一想，生活再人的一生中是什么？我到底该去向那里。 1.生活中的双人格&emsp;看了电视剧余欢水，我真切的感受到人的一天真的可以有很多中活法。在工作中，我们也可以做自己。规则之下，我们也要作乐。2.不断的学习&emsp;社会在发展，科技在进步，我们也要时刻提升自己，不光学识，内在也要丰富。",
      "link": "/2020/04/26/3a88bdf6.html"
    },
    {
      "title": "CentOs7安装Redis5.0.7",
      "text": "安装Ruby语言0.查看哪些是稳定版 http://www.ruby-lang.org/zh_cn/downloads/ 1.网站下载 https://cache.ruby-china.com/pub/ruby/ruby-2.6.6.tar.xz 2.也可以wget下载 1wget https://cache.ruby-lang.org/pub/ruby/2.5/ruby-6.6.6.tar.gz 3.若没有xz，先安装xz 123456789xz ruby-2.6.6.tar.xztar -vxf ruby-2.6.6.tarmv ruby-2.6.6 /usr/local/mkdir rubycd ruby-2.6.6/.configure --prefix=/usr/local/rubymakemake install./ruby -v 4.上面没有问题，配置环境 123echo \"export PATH=$PATH:/usr/local/ruby/bin\" &gt;&gt; /etc/profilesource /etc/profileruby -v 安装redis5.0.71.网站下载 http://download.redis.io/releases/ 2.解压 123tar -vxf redis-5.0.7.tar.gzmv redis-5.0.7 /usr/local/mkdir redis 3.简易配置 1234567cd redis-5.0.7/vim redis.conf----ctrl+ins复制#bind 127.0.0.1 protected-mode no timeout 3600 daemonize yes 4.安装 12345678cd redis-5.0.7/makemake install prefix=/usr/local/rediscd ../redismkdir etccd etcmkdir logcp /usr/local/redis-5.0.7/redis.conf /usr/local/redis/etc/ 5.启动 123cd /usr/local/redis/bin./redis-server ../etc/redis.conf./redis-cli -c -p 6379 集群配置1.配置redis.conf 12345678910111213141516cd /usr/local/redismkdir etcmkdir logcd etcmkdir 8000 8001 8002 8003 8004 8005cp /usr/local/redis-5.0.7/redis.conf /usr/local/redis/etc/8000/vim 8000/redis.conf--logfile \"/usr/local/redis/log/6379.log\"dbfilename dump8000.rdbappendonly yesappendfilename \"appendonly6379.aof\"cluster-enabled yescluster-config-file nodes_8000.conf cluster-node-timeout 15000 :%s/6379/8000/g 2.创建集群，8003，8004，8005之后分 12redis-cli --cluster create 192.168.246.130:8000 192.168.246.130:8001192.168.246.130:8002 3.登录 12cluster infocluster nodes 4.动态添加节点，启动8003，8004，8005 1234redis-cli --cluster add-node 192.168.246.130:8005 192.168.246.130:8000redis-cli -c -p 8000cluster info cluster nodes 查看状态 5.动态添加从节点 123redis-cli --cluster add-node 192.168.246.130:8003 192.168.246.130:8000 --cluster-slave --cluster-master-id 25f77d1d595a1b7bad8f14058914792fcc3bad4aredis-cli --cluster add-node 192.168.246.130:8004 192.168.246.130:8001 --cluster-slave --cluster-master-id 5e2633717488152e8e8ad640b73b5b937e1d08aaredis-cli --cluster add-node 192.168.246.130:8005 192.168.246.130:8002 --cluster-slave --cluster-master-id 75c81e6f02e8e9cd32235b65a35f6f54d08b01b1 6.一键添加节点 1redis-cli --cluster add-node 192.168.246.130:8000 192.168.246.130:8001 192.168.246.130:8002 192.168.246.130:8003 192.168.246.130:8004 192.168.246.130:8005 --cluster-replicas 1 一主一丛",
      "link": "/2020/09/05/3b63363d.html"
    },
    {
      "title": "CentOs7安装Rabbitmq",
      "text": "装erlang语言在rabbitmq官网查看对应版本号https://www.rabbitmq.com/which-erlang.html 安装依赖1yum -y install gcc glibc-devel make ncurses-devel openssl-devel xmlto perl wget gtk2-devel binutils-devel erlang官网下载1.http://erlang.org/download/ 选择你所需要的版本下载 2.也可以这样下载，但是比较慢 1wget http://erlang.org/download/opt_src_22.0.tar.gz 解压1tar -zxvf opt_src_22.0.tar.gz 移到local目录1mv opt_src_22.0 /usr/local/ 进入目录，编译，配置安装路径123cd /usr/local/opt_22.0/mkdir ../erlang./configure --prefix=/usr/local/erlang 编译时出现这个可以先忽略 安装1maike install 添加环境变量，可以echo输入，也可以在/etc/profile中直接输入1234echo 'export PATH=$PATH:/usr/local/erlang/bin' &gt;&gt; /etc/profilesource /etc/profileerlhalt().b 安装RabbitmqGitHub下载地址https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.15 下载 1wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.15/rabbitmq-server-generic-unix-3.7.15.tar.xz 这里由于是tar.xz格式，需要安装 1yum install -y xz 解压 1/bin/xz -d rabbitmq-server-generic-unix-3.7.15.tar.xz 第二次解压 1tar -xvf rabbitmq-server-generic-unix-3.7.15.tar 移动到local 12mv rabbitmq_server-3.7.15/ /usr/local/mv /usr/local/rabbitmq_server-3.7.15 rabbitmq 配置环境变量 1echo 'export PATH=$PATH:/usr/local/rabbitmq/sbin' &gt;&gt; /etc/profile 刷新环境变量 1source /etc/profile 创建配置目录 1mkdir /etc/rabbitmq 启动、停止、网页端123rabbitmq-server -detached //后台启动rabbitmqctl stoprabbitmqctl status 打开5672/15672端口，或者关闭防火墙 web插件1rabbitmq-plugins enable rabbitmq_management 访问 1http://127.0.0.1:1562/ 用户管理查看所有用户 1rabbitmqctl list_users 添加一个用户 1rabbitmqctl add_user admin 123456 配置权限 1rabbitmqctl set_permissions -p \"/\" admin \".*\" \".*\" \".*\" 查看用户权限 1rabbitmqctl list_user_permissions admin 设置tag 1rabbitmqctl set_user_tags admin administrator 删除用户 1rabbitmqctl delete_user guest",
      "link": "/2020/09/05/dfc98018.html"
    },
    {
      "title": "去除ES云服务器恶意命令",
      "text": "云服务出现占用CPU-90%的恶意命令云服务提供的信息 先查看进程，选择top命令，查看结果： CPU占用率达到100%，且不是我执行的命令，果断找出执行路径。使用如下命令，通过 PID 获取对应文件的路径。然后，找到并删除对应的文件。 1ls -l /proc/$pid/exe 这里的pid，我这里是14560。找到路径，删除命令或者文件。若存在恶意 minerd、tplink 进程，也查找出来删除。 下面用的命令是进行删除出现这个提示的命令或文件： 1cannot remove ‘phpupdate’: Operation not permitted 可以使用以下命令去删除文件 123lsattr 文件/命令 --查看隐藏属性chattr 隐藏属性 文件/命令rm -rf 文件/命令 -- 重新执行删除 最后在重新查看，进程，是否有类似很高的进程，又不是你自己的。",
      "link": "/2020/09/05/76531017.html"
    },
    {
      "title": "微风拂面，杨柳倒垂",
      "text": "​ 位于西南方向的皮德堡虹吸湾，这里背靠老鹰崖，前方是一片丛山峻岭，向下有一条小路蜿蜒进入，不是常年居住在附近的山民，也许走不到这里。我们的故事也是从这里开始的，也许这是一个梦，也许也是生活的缩影，谁又能说明白这些呢？ ​ 淅淅沥沥的小雨下个不停，周围的植物叶承接着一滴一滴的雨，叶子弯成半月，积累雨滴过重向下流去，在芭蕉树那里也发生着相同的事情。一滴一滴的雨留在一个棕灰色的坚果上，这么个地方，怎么会出现这个坚果呢？不知道，说不明白，天上飞的，地下游的，风刮得，谁说的准呢。。。 ​ 东南方向嗖嗖的游走过来一只松鼠，它的眼睛里看着这个坚果一样的东西，眼睛里冒着光，它前脚紧抓地面，飞快的往它方向跑去。手中抱着坚果，往它的芭蕉树叶大的地方躲去，现在没有雨了，它的牙齿狠狠地向下咬去，刺溜，没有在坚果上留下痕迹，又试了几下，又试了几下。放弃了，松鼠不知到这是怎么回事，它明明是坚果啊！怎么不能吃呢？松鼠刨了一个洞把它埋了起来，它要以后再来这里，找到这个芭蕉树下的坚果。 ​ 再大地的给养下，坚果破土，长出了几寸的嫩牙，清白的茎秆，翠绿的叶子，就再那里静静的立着。从地面看，应该是一丁点，但是从种子出发，就是立着的。吸收着穿过芭蕉叶的刺眼的阳光，吸收着土里浸泡的水等营养物质，就这样立着，每天阳光雨露，微风拂叶，云卷云舒。 ​ 天上的云，变化是不一样的。一会随着风从远方往这里移动，一会变成其他形状，云不会觉得难过，变得不像自己，谁都可以改变它。阳光能改变它，风能改变它，飞在天上的事物能改变它。性物异型，云是随性的，性格温和，与世无争，看着",
      "link": "/2020/10/05/5fa600f2.html"
    },
    {
      "title": "Python导出SqlServer数据字典",
      "text": "定义三个方法1.定义一个获取数据的getData()方法2.定义一个导出excel表的方法exportSqlServer()3.定义一个获取类型typeof()的方法，用作查询出来的数据被识别 下面直接展示代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147from datetime import datetimeimport osimport pymssql as pymssqlimport xlwtdef getData(): connect= pymssql.connect(host, 'sa', 密码, 数据库名); cur = connect.cursor(); query = ''' SELECT tableName = D.name , # 我合并单元格是按照这里的表的重复合并的，若用case whern end 结构，则不能合并，会出错 tableIntroduce = isnull(F.value,''), sort = A.colorder, fieldName = A.name, catogary = B.name, bytes = A.Length, lengths = COLUMNPROPERTY(A.id,A.name,'PRECISION'), scales = isnull(COLUMNPROPERTY(A.id,A.name,'Scale'),0), isOrNotNull = Case When A.isnullable=1 Then '√'Else '' End, primarays = Case When exists(SELECT 1 FROM sysobjects Where xtype='PK' and parent_obj=A.id and name in ( SELECT name FROM sysindexes WHERE indid in( SELECT indid FROM sysindexkeys WHERE id = A.id AND colid=A.colid))) then '√' else '' end, defauts = isnull(E.Text,''), annotations = isnull(G.[value],'') FROM syscolumns A Left Join systypes B On A.xusertype=B.xusertype Inner Join sysobjects D On A.id=D.id and D.xtype='U' and D.name&lt;&gt;'dtproperties' Left Join syscomments E on A.cdefault=E.id Left Join sys.extended_properties G on A.id=G.major_id and A.colid=G.minor_id Left Join sys.extended_properties F On D.id=F.major_id and F.minor_id=0 --where d.name='OrderInfo' --如果只查询指定表,加上此条件 Order By A.id,A.colorder''' cur.execute(query) data = cur.fetchall() # 元组类型 return datadef exportExcel(name): data = getData() myExcel = xlwt.Workbook('encoding=utf-8') # 定义表的宽 sheet1 = myExcel.add_sheet(name, cell_overwrite_ok=True) sheet1.col(0).width = 300 * 20 sheet1.col(1).width = 400 * 20 sheet1.col(2).width = 100 * 20 sheet1.col(3).width = 300 * 20 sheet1.col(4).width = 256 * 20 sheet1.col(5).width = 180 * 20 sheet1.col(6).width = 180 * 20 sheet1.col(7).width = 100 * 20 sheet1.col(8).width = 100 * 20 sheet1.col(9).width = 100 * 20 sheet1.col(10).width = 180 * 20 sheet1.col(11).width = 800 * 20 # 设置居中 a1 = xlwt.Alignment() a1.horz = 0x02 a1.vert = 0x01 style = xlwt.XFStyle() # 赋值style为XFStyle为初始化样式 style.alignment = a1 today = datetime.today() # 获取当前日期，得到一个datetime对象如：(2019, 7, 2, 23, 12, 23, 424000) today_date = datetime.date(today) # 将获取到的datetime对象仅取日期如：2019-7-2 items = ['数据表', '表名', '字段序号', '字段', '类型', '占用字节数', '长度', '小数点', '是否为空', '是否为主键', '默认值','注释'] for col in range(len(items)): sheet1.write(0, col, items[col]) # 合并第二列的name,从content获取第一列数据，[(&quot;Choleen&quot;,&quot;xxx&quot;),()] first_col = [] for i in range(len(data)): first_col.append(data[i][0]) print(&quot;first_col:&quot;, first_col) # 去掉重复的列数据，并顺序不变 nFirst_col = list(set(first_col)) nFirst_col.sort(key=first_col.index) print(&quot;nFirst_col:&quot;, nFirst_col) row = 1 for i in nFirst_col: count = first_col.count(i) # 计算重复的元素个数 mergeRow = row + count - 1 # 合并后的上行数， sheet1.write_merge(row, mergeRow, 0, 0, i, style) # 第一列 sheet1.write_merge(row, mergeRow, 1, 1, i, style) row = mergeRow + 1 # 从下一行开始写入 # 获取data[i]中的第二个元素，循环写入 for row in range(len(data)): for col in range(1, len(data[row])): result = data[row][col] str = typeof(result) # 获取类型 if str == None: # 不能识别的类型，需要转换 result = result.decode('utf-8') sheet1.write(row + 1, col, result, style) fileName = name + '.xls' rootPath = os.path.dirname(os.path.abspath('ExportSqlServer.py')) + '\\\\' print(rootPath) flag = os.path.exists(rootPath + fileName) if flag: os.remove(rootPath + fileName) myExcel.save(fileName) else: myExcel.save(fileName) def typeof(variate): type = None if isinstance(variate, int): type = &quot;int&quot; elif isinstance(variate, str): type = &quot;str&quot; elif isinstance(variate, float): type = &quot;float&quot; elif isinstance(variate, list): type = &quot;list&quot; elif isinstance(variate, tuple): type = &quot;tuple&quot; elif isinstance(variate, dict): type = &quot;dict&quot; elif isinstance(variate, set): type = &quot;set&quot; return typeif __name__ == '__main__': print(&quot;这是sqlServer导出的数据字典&quot;); # response = chardet.detect(b'\\xe7\\x94\\xa8\\xe6\\x88\\xb7\\xe8\\xa1\\xa8') # print(response) exportExcel(&quot;user表&quot;) 在编写代码过程中出现了，中文乱码。python3会自动转换未unicode，我们来看下转换过程： 1234567 UTF-8/GBK --》 decode 解码 --》 Unicode Unicode --》 encode 编码 --》 GBK / UTF-8 ``` 这里的代码是Unicode,要转换成明文，就需要decode方法，只能是unicode的格式才能，若是int，str类型则会报错 ```angular2html明文 -- encode --》Unicode--》gbk，utf-8明文 《-- decode -- Unicode 《-- gbk，utf-8 so，这样就可以了。完成。",
      "link": "/2020/03/17/5226e067.html"
    },
    {
      "title": "Redis的分布式锁",
      "text": "采用一定的逻辑去实现锁的概念，不是本身固有的功能。",
      "link": "/2020/10/05/b846387f.html"
    },
    {
      "title": "DynamicSource动态数据源",
      "text": "一、了解动态数据源场景这里介绍一下一个类AbstractRoutingDataSource 这个类是我们切换数据源的核心，我们进入此类了解一番。 此类中的方法determineTargetDataSource() ，它返回的是一个key，不同的key实现可动态路由的数据源，下面是此方法的源码: 123456789101112131415protected DataSource determineTargetDataSource() { Assert.notNull(this.resolvedDataSources, \"DataSource router not initialized\"); //这个获得key的方法，可以由自定义的数据源类，继承AbstractRoutingDataSource类，重写 Object lookupKey = determineCurrentLookupKey(); //从数据源的Map中根据单进程获取的key，取出DataSource DataSource dataSource = this.resolvedDataSources.get(lookupKey); if (dataSource == null &amp;&amp; (this.lenientFallback || lookupKey == null)) { //若map中没有对应的数据源，则取默认的数据源 dataSource = this.resolvedDefaultDataSource; } if (dataSource == null) { throw new IllegalStateException(\"Cannot determine target DataSource for lookup key [\" + lookupKey + \"]\"); } return dataSource; } 从上面的代码中，我们知道， 这个数据源是封装到Map结构中的 需要设置默认数据源 这两方面，需要我们在本地，创建一个类，去封装数据源。 二、封装数据源到Map&lt;Object,DataSource&gt;和设置默认数据源在Demo中创建一个类DynamicDatasourceConfiguration;对于此类，我们需要从application.yml中获取配置参数，即数据源配置，比如url、username、password、driver-class-name等。下面有两种方法获取配置参数： 实现EnvironmentAware接口, 实现setEnvironment(Environment env)此方法，从env参数中可获取数据库配置参数。 可以创建实体类接收，从此类中获取。可以用@ConfigurationProperties(prefix = &quot;&quot;)注解。 我的Demo，从Environment 参数中获取，若数据源多，Springboot启动时，从spring容器中根据beans的name获取到，对应的值，数据源，加载一次即可。 1.封装数据源类如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * @description 数据源配置 * @author 山沉 * @公众号 九月的山沉 * @微信号 Applewith520 * @个人博客 Choleen95.github.com * @博客 https://www.cnblogs.com/Choleen/ * @since 2021/1/1 22:02 */@Configuration@Component@MapperScan(basePackages = {\"com.example.es.mapper\"}, sqlSessionFactoryRef = \"sqlSessionFactory\")@PropertySource(value = \"classpath:application.yml\")public class DynamicDatasourceConfiguration implements EnvironmentAware{ private static final Logger logger = LoggerFactory.getLogger(DynamicDatasourceRegister.class); private static String PREFIX = \"spring.datasource\"; @Override public void setEnvironment(Environment env) { init(env); } //目标数据源 private Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;(); //默认数据源 private Object defaultTargetDataSource; @Bean(\"dynamicDataSource\") public DynamicDatasource init(Environment env){ String datasourceNames = env.getProperty(PREFIX+\".dynamicNames\"); MyAssert.isEmpty(datasourceNames,\"dataSource is null\"); String[] array = datasourceNames.split(\",\"); DynamicDatasource dynamicDatasource = new DynamicDatasource(); if(array.length == 1){ //只有一个 String type = array[0]; DataSource dataSource = buildDataSource(env, type); targetDataSources.put(type,dataSource); defaultTargetDataSource = dataSource; }else { //多个 for (String s : array) { DataSource dataSource = buildDataSource(env, s); targetDataSources.put(s,dataSource); } } dynamicDatasource.setTargetDataSources(targetDataSources); if(defaultTargetDataSource == null){ defaultTargetDataSource = targetDataSources.get(array[0]); DynamicDataSourceContextHolder.setRouteKey(array[0]); } dynamicDatasource.setDefaultTargetDataSource(defaultTargetDataSource); return dynamicDatasource; } public DataSource buildDataSource(Environment props, String type){ String dbNames = PREFIX+\".\"+type+ \".\"; String url = props.getProperty(dbNames+\"url\"); String username = props.getProperty(dbNames+\"username\"); String password = props.getProperty(dbNames+\"password\"); String driverClassName = props.getProperty(dbNames+\"driver-class-name\"); logger.info(\"加载数据源---------------&gt;{}\",url); DruidDataSource dataSource = DruidDataSourceBuilder.create().build(); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setDriverClassName(driverClassName); return dataSource; } @Bean public PlatformTransactionManager txManager(DataSource dynamicDataSource) { return new DataSourceTransactionManager(dynamicDataSource); } @Bean(\"sqlSessionFactory\") public SqlSessionFactory sqlSessionFactoryBean(@Autowired @Qualifier(\"dynamicDataSource\") DynamicDatasource dynamicDataSource) throws Exception { SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dynamicDataSource); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath*:mapper/**.xml\"));//mapper文件 return sqlSessionFactoryBean.getObject(); }} 2. 配置文件在application.yml中： 123456789101112131415161718192021spring: datasource: dynamicNames: mv,test mv: url: jdbc:mysql:///movie?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true username: root password: root driver-class-name: com.mysql.jdbc.Driver test: url: jdbc:mysql:///testdb?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true username: root password: root driver-class-name: com.mysql.jdbc.Driver druid: db-type: com.alibaba.druid.pool.DruidDataSource initial-size: 10 max-active: 100 min-idle: 3 max-wait: 5000 pool-prepared-statements: true max-pool-prepared-statement-per-connection-size: 100 3、自定以参数、继承类的参数3.1、这里先介绍一下AbstractRoutingSource中的参数：1234567891011121314151617public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean { @Nullable private Map&lt;Object, Object&gt; targetDataSources;//这个是目标数据源 @Nullable private Object defaultTargetDataSource;//默认数据源 private boolean lenientFallback = true; private DataSourceLookup dataSourceLookup = new JndiDataSourceLookup(); @Nullable private Map&lt;Object, DataSource&gt; resolvedDataSources;//已经解析的目标数据源 @Nullable private DataSource resolvedDefaultDataSource;//解析的默认数据源 在自定义类中参数，有默认数据源，和目标数据源： 123 private Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();//目标数据源private Object defaultTargetDataSource;//默认数据源 4、需要生成SqlSessionFactory的实例，交给Spring容器管理数据源封装了，在AbstracRoutingSource中可以根据routeKey去解析过的resolveDataSources中根据key获取数据源，即到此可以获取数据源了。但是没有让进程之间规定谁去访问哪一个数据源，为了避免出现混乱，我们这里需要用到ThreadLocal。 三、用ThreadLocal 避免数据源访问混乱自定义一个类，专门去获取数据源的key，即A进程的访问不影响B进程，避免B进程不知去找哪一个key，出现数据混乱。 如下代码12345678910111213141516public class DynamicDataSourceRouteKey { private static ThreadLocal&lt;String&gt; routeKey = new ThreadLocal&lt;&gt;(); //获取数据源名称 public static String getRouteKey() { return routeKey.get(); } //设置数据源名称 public static void setRouteKey(String type) { routeKey.set(type); } //清除数据源名 public static void clearContextHolder(){ routeKey.remove(); }} 从外访问接口： 可以在拦截器中设置数据源名 若有子进程，要在子进程中设置，在执行查询，指定routeKey 到此使用AbstractRoutingSource 实现动态数据源的切换功能完成。代码地址master分支：github-hillheavy地址",
      "link": "/2021/03/05/64a068f6.html"
    },
    {
      "title": "Elasticsearch的学习之旅",
      "text": "版权申明：本文仅适用于学习，更多内容请访问原创作者： 微信公众号：江南一点雨 博客：https://www.javaboy.org/ ElasticSearch简介1.1 LuceneLucene是一个开源、免费、高性能、纯java编写的全文检索引擎，可以算作是开源邻域最好的全文检索工具包。适用于很多语言，如C++、C#、paython等。它是出名的Doug Cutting的作品，当然还有hadoop也是他的。 Lucene主要特点： 简单 跨语言 强大的搜素引擎 索引速度快 索引文件兼容不同平台 1.2 ElasticSearchElasticSearch是一个分布式、可扩展、近实时性的高性能搜索与数据分析引擎，是基于Java编写，通过进一步封装Lucene，开发者可以用RESTful API 操作全文搜索。 整体上来说，ElasticSearch有三大功能： 数据搜集 数据分析 数据存储 ElasticSearch主要有如下特点： 分布式实时文件存储 实时分析的分布式搜索引擎 高可扩展性 可插拔的插件支持 所以可以有很多用例 应用程序搜索 网站搜索 1.3ElasticSearch安装首先是打开以下链接的Es官网，找到ElasticSearch： ES官网 ElasticSearch对应的JDK关系，如下链接： JDK对应关系 1.3.1单节点安装基本上正常的window、linux、mac等系统都可以使用。 在Centos7.x上解压文件后，解压后的目录含义如下： 目录 含义 modules 依赖模块目录 lib 第三方依赖库 logs 输出日志目录 plugins 插件目录 bin 可执行文件目录 config 配置文件目录 data 数据存储目录 启动方式： 进入到bin目录下，直接执行: 1[#]./elasticsearch 启动过程中出现的问题 ​ 原因：为了安全不允许使用root用户启动，es5之后的都不能使用添加启动参数或者修改配置文件等方法启动了, 创建一个用户就可以了 ​ 1. 创建用户choleen 1[root#]adduser choleen ​ 2. 创建用户密码，需要输入两次 1[root#]passwd choleen ​ 3. 将对应的文件夹权限赋给该用户 1[root#]chown -R choleen elasticsearch-7.10.0 ​ 4. 切换至choleen用户 1[root#]su choleen ​ 5. 进入bin启动，看到started就算成功 1[root#]./elasticsearch ​ 6. [root#]curl ip:9200，若看到json数据说明启动成功 ​ 可能没有成功，去elasticsearch.yml文件，更改network.host: 0.0.0.0即可，冒号后面又空格。 ​ 7. 在浏览器中输入localhost:9200访问，则需要更改配置文件。 当改完配置文件之后，会报如下错误： 最大文件描述4096对于es进程太小了，至少增加到65535 最大线程数量3754,对于这个用户太低了，至少增加到46096 最大虚拟内存65535太低，至少增加到262144 这个默认的发现设置不适用与生产使用，至少seed_host、seed_prividers、initial_master_node其中必须配置一个 解决方法： 切换到root ​ 1234567891011#文件[root#]echo \"* soft nofile 65535\" &gt;&gt; /etc/security/limits.conf [root#]echo \"* hard nofile 65535\" &gt;&gt; /etc/security/limits.conf#内存锁，不限制[root#]echo \"* soft memlock unlimited\" &gt;&gt; /etc/security/limits.conf[root#]echo \"* hard memlock unlimited\" &gt;&gt; /etc/security/limits.conf[root#]echo \"vm.max_map_count=262144\" &gt;&gt; /etc/sysctl.conf# 进程[root#]echo \"* soft nproc 4096\" &gt;&gt; /etc/security/limits.d/20-nproc.conf [root#] echo \"* hard nproc 4096\" &gt;&gt; /etc/security/limits.d/20-nproc.conf [root#] sysctl -p 对于jdk环境变量 jdk环境变量可以加在环境中，加es包里自带的。这个环境变量若不加，7.x版本的es启动会尝试在自己的程序所在路径获取jdk环境。若 要在这台机器启动kibana，可以加上，或者直接加到kibana启动脚本中。 12345[root#]cat &gt;&gt; /etc/profile.d/java.sh &lt;&lt;EOF&gt; export JAVA_ES_HOME=\"/home/software/elasticsearch-7.10.0/jdk\"&gt; export PATH=\\$JAVA_ES_HOME/bin:\\$PATH&gt; export CLASSPATH=.:\\$JAVA_ES_HOME/lib/dt.jar:\\$JAVA_ES_HOME/lib/tools.jar&gt; EOF 对于config/elasticsearch.yml配置文件修改 12345678910node.name: node-1bootstrap.memory_lock: falsebootstrap.system_call_filter: falsenetwork.host: 0.0.0.0http.port: 9200cluster.initial_master_nodes: [\"node-1\"]# head插件需要这两个配置http.cors.allow-origin: \"*\"http.cors.enabled: truehttp.max_content_length: 200mb 当看到started时，启动成功。 在内网执行,出现json字符串则成功 1[root#]crul ip:9200",
      "link": "/2021/03/05/3aad248e.html"
    },
    {
      "title": "springboot的java打印票据",
      "text": "Java打印的几个步骤 1构建springboot框架 2引入log日志 3构建java打印xml文件 4解析xml配置文件 5java打印 由于需要，现在要实现一个java打印的程序。我们开始第一步构建springboot项目。 第一步打开idea，new 一个Project，选择Spring initializr 初始化一个springboot项目。在pom文件中按下alt + insert 选择Dependency使用idea的引入maven依赖。如下： &lt;!--基础依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--httpClient连接--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--gogle的Zxing生成二维码--&gt; &lt;!-- https://mvnrepository.com/artifact/com.google.zxing/core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.google.zxing/javase --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--判断非空等的工具依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;me.javy&lt;/groupId&gt; &lt;artifactId&gt;javy-helper&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--使用pojo解析xml文件所用--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;/dependency&gt; 下面是我的类结构图：配置httpClient 1.httpClient连接可以远程访问服务器，获取数据，有时需要。所以这里也配一下。下面我们进行httpClient配置。在config包下建一个httpClient和httpCLientService，一个是构建对象一个是连接服务。在properties中写入httpclient的基础配置： #http配置服务 #最大连接数 http.maxTotal = 100 #并发数 http.defaultMaxPerRoute = 20 #创建连接的最长时间 http.connectTimeout=1000 #从连接池中获取到连接的最长时间 http.connectionRequestTimeout=500 #数据传输的最长时间 http.socketTimeout=10000 #提交请求前测试连接是否可用 http.staleConnectionCheckEnabled=true 2.在httpClient往容器中注入Bean属性，采用注解@Value来实现如下： @Configuration public class HttpClient { @Value(&quot;${http.maxTotal:1}&quot;) private Integer maxTotal; @Value(&quot;${http.defaultMaxPerRoute:1}&quot;) private Integer defaultMaxPerRoute; @Value(&quot;${http.connectTimeout:1}&quot;) private Integer connectTimeout; @Value(&quot;${http.connectionRequestTimeout:1}&quot;) private Integer connectionRequestTimeout; @Value(&quot;${http.socketTimeout:1}&quot;) private Integer socketTimeout; @Value(&quot;${http.staleConnectionCheckEnabled:true}&quot;) private boolean staleConnectionCheckEnabled; } 1.下面我们首先实列化一个连接池管理器，设置最大连接数，并发连接数。 @Bean(name = &quot;httpClientConnectionManager&quot;) public PoolingHttpClientConnectionManager getHttpClientConnectionManager(){ PoolingHttpClientConnectionManager httpClientConnectionManager = new PoolingHttpClientConnectionManager(); //最大连接数 httpClientConnectionManager.setMaxTotal(maxTotal); //并发数 httpClientConnectionManager.setDefaultMaxPerRoute(defaultMaxPerRoute); return httpClientConnectionManager; } 2.实列化连接池，设置连接池管理器。我们需要用到spring的@Qualifier，其意为合格者，用于区分注解实例，参数名为我们的连接池管理器注解名称。 @Bean(name = &quot;httpClientBuilder&quot;) public HttpClientBuilder getHttpClientBuilder(@Qualifier(&quot;httpClientConnectionManager&quot;)PoolingHttpClientConnectionManager httpClientConnectionManager){ //HttpClientBuilder中的构造方法被protected修饰，所以这里不能直接使用new来实例化一个HttpClientBuilder，可以使用HttpClientBuilder提供的静态方法create()来获取HttpClientBuilder对象 HttpClientBuilder httpClientBuilder = HttpClientBuilder.create(); httpClientBuilder.setConnectionManager(httpClientConnectionManager); return httpClientBuilder; } 3.注入连接池，获取client对象 @Bean public CloseableHttpClient getCloseableHttpClient(@Qualifier(&quot;httpClientBuilder&quot;) HttpClientBuilder httpClientBuilder){ return httpClientBuilder.build(); } 4.Builder是requestConfig中的一个内部类，通过requestConfig的custom方法获取builder的对象，设置builder的连接信息。 @Bean(name = &quot;builder&quot;) public RequestConfig.Builder getBuilder(){ RequestConfig.Builder builder = RequestConfig.custom(); return builder.setConnectTimeout(connectTimeout)//创建连接的最长时间 .setConnectionRequestTimeout(connectionRequestTimeout)//从连接池中获取的连接最长时间 .setSocketTimeout(socketTimeout)//数据传输的最长时间 .setStaleConnectionCheckEnabled(staleConnectionCheckEnabled);//提交请求前测试连接是否可用 } 5.用builder构建一个requestConfig对象 @Bean public RequestConfig getRequestConfig(@Qualifier(&quot;builder&quot;) RequestConfig.Builder builder){ return builder.build(); } 到此httpclient基础信息初始化配置完成。",
      "link": "/2020/03/25/f4f56a79.html"
    },
    {
      "title": "springboot的java打印票据-2",
      "text": "Java打印之httpClient服务前面我们配置了httpClient实例，现在我们配置服务，我们配置get和post请求，用于之后的请求。1.注入实例时，若required没有或是ture则都是默认有这个实例的，不然肯定失败! @Service public class HttpClientService { @Autowired(required=false) private CloseableHttpClient httpClient; @Autowired(required=false) private RequestConfig config; } 1.这里我们首先编写get请求不带参数，如果状态码200，则会返回body，若不是200，则返回null。 public String doGet(String url) throws Exception { // 声明 http get 请求 HttpGet httpGet = new HttpGet(url); // 装载配置信息 httpGet.setConfig(config); // 发起请求 CloseableHttpResponse response = this.httpClient.execute(httpGet); // 判断状态码是否为200 if (response.getStatusLine().getStatusCode() == 200) { // 返回响应体的内容 return EntityUtils.toString(response.getEntity(), \"UTF-8\"); } return null; } 2.然后编写get带参数的请求。这里的带参结构都是map结构，我们可以引入解析json字符串为实体的依赖。 public String doGet(String url, Map&lt;String, Object&gt; map) throws Exception { URIBuilder uriBuilder = new URIBuilder(url); if (map != null) { // 遍历map,拼接请求参数 for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) { uriBuilder.setParameter(entry.getKey(), entry.getValue().toString()); } } // 调用不带参数的get请求 return this.doGet(uriBuilder.build().toString()); } 3.设置带参数的post请求 public HttpResult doPost(String url, Map&lt;String, Object&gt; map) throws Exception { // 声明httpPost请求 HttpPost httpPost = new HttpPost(url); // 加入配置信息 httpPost.setConfig(config); // 判断map是否为空，不为空则进行遍历，封装from表单对象 if (map != null) { List&lt;NameValuePair&gt; list = new ArrayList&lt;NameValuePair&gt;(); for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) { list.add(new BasicNameValuePair(entry.getKey(), entry.getValue().toString())); } // 构造from表单对象 UrlEncodedFormEntity urlEncodedFormEntity = new UrlEncodedFormEntity(list, \"UTF-8\"); // 把表单放到post里 httpPost.setEntity(urlEncodedFormEntity); } // 发起请求 CloseableHttpResponse response = this.httpClient.execute(httpPost); return new HttpResult(response.getStatusLine().getStatusCode(), EntityUtils.toString( response.getEntity(), \"UTF-8\")); } 4.不带参数的请求 public HttpResult doPost(String url) throws Exception { return this.doPost(url, null); } 5.还可以是json格式的参数，进行post请求 public String doPostJson(String url, String json) throws Exception { // 创建http POST请求 HttpPost httpPost = new HttpPost(url); httpPost.setConfig(config); if(null != json){ //设置请求体为 字符串 StringEntity stringEntity = new StringEntity(json,\"UTF-8\"); httpPost.setEntity(stringEntity); } CloseableHttpResponse response = null; try { // 执行请求 response = httpClient.execute(httpPost); // 判断返回状态是否为200 if (response.getStatusLine().getStatusCode() == 200) { return EntityUtils.toString(response.getEntity(), \"UTF-8\"); } } finally { if (response != null) { response.close(); } } return null; } 到此，我们就把httpClient设置好了。要在那里使用直接注入@Autowired。 logger日志配置在项目中，我们会发生很多异常，和需要打印信息。这里就要配置日志了。在properties中我们配置一些基础信息： # 日志文件 logging.file.path=D:/logs/PrintLog/ #文件路径 logging.file.name=Print.log # 文件名 logging.file.max-size=100MB #文件定义最大的大小 logging.file.max-history=7 # 日志保存的最长时间 logging.config=classpath:logging-config.xml #配置文件路径 1.配置logging-config.xml，里面有几个节点。logback配置之Configuration。中有几个属性。其中： 1.scan：属性为true，文件发生改变，将会重新加载，defaut=true 2.scanPeriod –字面意思扫描时间段，设置监测配置文件是否有时间间隔，没有给出具体时间间隔，单位毫秒，默认为1分钟。 3.debug 属性为true时，将打印出logback的内部日志信息，默认为false。 2.Configuration的子节点： 1.contextName 上下文名称。用于区分不同的程序记录，默认为defaut，这里没有配置，一旦配置，便不能修改 2.变量property，有name和value属性，设置之后可以在上下文中${name}使用这里只配置root，使用appender进行输出日志文件及内容 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;configuration debug=\"false\"&gt; &lt;!--设置存储路径变量--&gt; &lt;property name=\"LOG_HOME\" value=\"D:/logs/PrintLog/\"/&gt; &lt;!--控制台输出appender--&gt; &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!--设置输出格式--&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;!--设置编码--&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--文件输出,时间窗口滚动--&gt; &lt;appender name=\"timeFileOutput\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!--日志名,指定最新的文件名，其他文件名使用FileNamePattern --&gt; &lt;File&gt;${LOG_HOME}/jiuluPrint.log&lt;/File&gt; &lt;!--文件滚动模式--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!--日志文件输出的文件名,可设置文件类型为gz,开启文件压缩--&gt; &lt;FileNamePattern&gt;${LOG_HOME}/info.%d{yyyy-MM-dd}.%i.log.gz&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数--&gt; &lt;MaxHistory&gt;7&lt;/MaxHistory&gt; &lt;!--按大小分割同一天的--&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;!--输出格式--&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;!--设置编码--&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--指定基础的日志输出级别--&gt; &lt;root level=\"INFO\"&gt; &lt;!--appender将会添加到这个loger--&gt; &lt;appender-ref ref=\"console\"/&gt; &lt;appender-ref ref=\"timeFileOutput\"/&gt; &lt;/root&gt; &lt;/configuration&gt; 这样启动之后就会在设置路径下生成日志文件了。启动之后就会更替默认的日志格式。个人博客:山沉CSDN博客园",
      "link": "/2020/03/26/fabea79c.html"
    },
    {
      "title": "SpringBoot的java打印票据-3",
      "text": "配置打印xml文件并解析打印东西，先设置纸张大小，各种参数。若把数字直接填写到打印过程，之后的更改比较麻烦，这里配置一个xml文件，所有的参数都从这里取出打印。 1.构建printSettings.xml文件，放置于resources中。 &lt;print&gt; &lt;!-- 打印机设置 --&gt; &lt;choosePrint&gt;3&lt;/choosePrint&gt; &lt;!-- 打印任务名称 --&gt; &lt;printName&gt;PDF&lt;/printName&gt; &lt;!-- 打印机选择,为空时选择默认打印机 --&gt; &lt;defPrintName&gt;&lt;/defPrintName&gt; &lt;!-- true:配置生效,false:配置不生效 --&gt; &lt;isPrint&gt;true&lt;/isPrint&gt; &lt;!-- 二维码尺寸90*90 --&gt; &lt;qrcodeSize&gt;70&lt;/qrcodeSize&gt; &lt;!--存放二维码的基本地址--&gt; &lt;basePath&gt;G:\\JavaPrintQRCode\\&lt;/basePath&gt; &lt;!-- 纸张设置 --&gt; &lt;paper&gt; &lt;!-- 打印纸张设置paperWidth,paperHeight --&gt; &lt;paperWidth&gt;595&lt;/paperWidth&gt; &lt;paperHeight&gt;842&lt;/paperHeight&gt; &lt;!-- 打印区域设置x,y,width,height --&gt; &lt;x&gt;10&lt;/x&gt; &lt;y&gt;15&lt;/y&gt; &lt;width&gt;580&lt;/width&gt; &lt;height&gt;840&lt;/height&gt; &lt;/paper&gt; &lt;!--条形码参数--&gt; &lt;tmParameters&gt; &lt;paperWidth&gt;200&lt;/paperWidth&gt; &lt;paperHeight&gt;150&lt;/paperHeight&gt; &lt;useWidth&gt;180&lt;/useWidth&gt; &lt;useHeight&gt;100&lt;/useHeight&gt; &lt;useX&gt;5&lt;/useX&gt; &lt;useY&gt;10&lt;/useY&gt; &lt;x&gt;20&lt;/x&gt; &lt;y&gt;40&lt;/y&gt; &lt;width&gt;170&lt;/width&gt; &lt;height&gt;50&lt;/height&gt; &lt;path&gt;D:\\JavaPrintTmCode\\&lt;/path&gt; &lt;titleFontName&gt;宋体&lt;/titleFontName&gt; &lt;titleSize&gt;10&lt;/titleSize&gt; &lt;addressSize&gt;20&lt;/addressSize&gt; &lt;numberSize&gt;10&lt;/numberSize&gt; &lt;companyName&gt;玖陆物流&lt;/companyName&gt; &lt;tmPrintName&gt;Xprinter XP-365B&lt;/tmPrintName&gt; &lt;!--&lt;tmPrintName&gt;360&lt;/tmPrintName&gt;--&gt; &lt;/tmParameters&gt; &lt;!-- 打印数据参数设置 --&gt; &lt;dataset&gt; &lt;data x=\"5\" y=\"30\" name=\"startAddress\" cellWidth=\"\" cellHeight=\"\" font=\"宋体\" size=\"16\"/&gt; &lt;datas name=\"appGoodsOrder\" type=\"\"&gt; &lt;data x=\"110\" y=\"110\" name=\"goodsName\" /&gt; &lt;data x=\"205\" y=\"110\" name=\"goodsPkgs\" /&gt; &lt;data x=\"295\" y=\"110\" name=\"goodsPackage\" /&gt; &lt;/datas&gt; &lt;!--费用格式--&gt; &lt;datas name=\"appFeeOrder\" type=\"\"&gt; &lt;data x=\"70\" y=\"230\" name=\"feeText\" /&gt; &lt;/datas&gt; &lt;table x=\"\" y=\"\" width=\"\" height=\"\"&gt; &lt;tr width=\"\" height=\"\"&gt; &lt;td width=\"\" height=\"\" colspan=\"\" rowspan=\"\" &gt;&lt;/td&gt; &lt;td width=\"\" height=\"\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/dataset&gt; &lt;/print&gt; 设置好之后，到pom文件中按下alt + insert 引入maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;/dependency&gt; 让节点构成实体。这样方便我们在打印过程中取值。下面是我的实体结构，从最上层逐步往下。其中PrintSettings类是最上层。在加入注解时，可能会有重复的名称，我们需要加入 @XmlTransient注解，这样只在@XmlRootElement注解的实体中找寻有无重复，不管其他类的变量。展示一下最上层和其次顺序的类。 package com.cargo.order.settings; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import javax.xml.bind.annotation.*; /** *打印设置POJO * @since 2020/3/25 8:46 **/ @Data @AllArgsConstructor @NoArgsConstructor @XmlRootElement(name = \"print\") @XmlAccessorType(XmlAccessType.FIELD) public class PrintSettings { @XmlElement(name = \"choosePrint\") private String choosePrint; @XmlElement(name = \"printName\") private String printName; @XmlElement(name = \"isPrint\") private Boolean isPrint; @XmlElement(name = \"qrcodeSize\") private Integer qrcodeSize; @XmlElement(name = \"basePath\") private String basePath; @XmlElement(name = \"paper\") private Paper paper; @XmlElement(name = \"dataset\") private DataSet dataSet; @XmlElement(name = \"tmParameters\") private TmParameters tmParameters; public TmParameters getTmParameters() { return tmParameters; } public void setTmParameters(TmParameters tmParameters) { this.tmParameters = tmParameters; } public String getChoosePrint() { return choosePrint; } public void setChoosePrint(String choosePrint) { this.choosePrint = choosePrint; } public String getPrintName() { return printName; } public void setPrintName(String printName) { this.printName = printName; } public Boolean getPrint() { return isPrint; } public void setPrint(Boolean print) { isPrint = print; } public Integer getQrcodeSize() { return qrcodeSize; } public void setQrcodeSize(Integer qrcodeSize) { this.qrcodeSize = qrcodeSize; } public Paper getPaper() { return paper; } public void setPaper(Paper paper) { this.paper = paper; } public DataSet getDataSet() { return dataSet; } public void setDataSet(DataSet dataSet) { this.dataSet = dataSet; } public String getBasePath() { return basePath; } public void setBasePath(String basePath) { this.basePath = basePath; } } 然后展示一下Paper实体. package com.cargo.order.settings; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import javax.xml.bind.annotation.XmlAttribute; import javax.xml.bind.annotation.XmlElement; import javax.xml.bind.annotation.XmlRootElement; import javax.xml.bind.annotation.XmlTransient; @Data @AllArgsConstructor @NoArgsConstructor @XmlRootElement(name = \"paper\") public class Paper { @XmlElement(name = \"paperWidth\") private Integer paperWidth; @XmlElement(name = \"paperHeight\") private Integer paperHeight; @XmlElement(name = \"x\") private Integer x; @XmlElement(name = \"y\") private Integer y; @XmlElement(name = \"width\") private Integer width; @XmlElement(name = \"height\") private Integer height; @XmlTransient public Integer getPaperWidth() { return paperWidth; } public void setPaperWidth(Integer paperWidth) { this.paperWidth = paperWidth; } @XmlTransient public Integer getPaperHeight() { return paperHeight; } public void setPaperHeight(Integer paperHeight) { this.paperHeight = paperHeight; } @XmlTransient public Integer getX() { return x; } public void setX(Integer x) { this.x = x; } @XmlTransient public Integer getY() { return y; } public void setY(Integer y) { this.y = y; } @XmlTransient public Integer getWidth() { return width; } public void setWidth(Integer width) { this.width = width; } @XmlTransient public Integer getHeight() { return height; } public void setHeight(Integer height) { this.height = height; } } 在要用的地方直接静态代码块，加载一次，使用，比如： private static PrintSettings printSettings; static { try { //读取Resource目录下的XML文件 Resource resource = new ClassPathResource(\"printSettings.xml\"); //利用输入流获取XML文件内容 BufferedReader br = new BufferedReader(new InputStreamReader(resource.getInputStream(), \"UTF-8\")); StringBuffer buffer = new StringBuffer(); String line = \"\"; while ((line = br.readLine()) != null) { buffer.append(line); } br.close(); //XML转为JAVA对象 PrintSettings settings = (PrintSettings) XmlBuilder.xmlStrToObject(PrintSettings.class, buffer.toString()); printSettings = settings; }catch (Exception e){ logger.error(\"异常\",e); } } 到此xml文件配置好了，也可以使用。代码已上传到gitee",
      "link": "/2020/03/27/3a1bc5b7.html"
    },
    {
      "title": "Js引入百度地图",
      "text": "工作中有时需要根据项目需求引入地图进行展示数据，现在做一个超简单的引入。推荐百度api，全是中文解释，很方便。百度API* 引入百度js1.新建一个html页面，引入js &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"expires\" content=\"0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta content=\"width=device-width, initial-scale=1\" name=\"viewport\" /&gt; &lt;script type=\"text/javascript\" src=\"http://api.map.baidu.com/api?v=3.0&amp;ak=gYR4wlvCmPyZYq8ggttE3fkGuBC5sOUB\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/static/lib/jquery.liMarquee/jquery.liMarquee.js\"&gt;&lt;/script&gt; &lt;script&gt; (function(a,h,g,f,e,d,c,b){b=function(){d=h.createElement(g);c=h.getElementsByTagName(g)[0];d.src=e;d.charset=\"utf-8\";d.async=1;c.parentNode.insertBefore(d,c)};a[\"SeniverseWeatherWidgetObject\"]=f;a[f]||(a[f]=function(){(a[f].q=a[f].q||[]).push(arguments)});a[f].l=+new Date();if(a.attachEvent){a.attachEvent(\"onload\",b)}else{a.addEventListener(\"load\",b,false)}}(window,document,\"script\",\"SeniverseWeatherWidget\",\"/static/lib/xy.weather/widget2.bundle.js?t=\"+parseInt((new Date().getTime() / 100000000).toString(),10))); &lt;/script&gt; &lt;script src=\"js/TrackDisplayByBaidu.js\"&gt;&lt;/script&gt; &lt;title&gt;轨迹图&lt;/title&gt; &lt;style type=\"text/css\"&gt; .anchorBL{ display:none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"allmap\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 这样html准备好了。2.创建自定义的js文件 /** * 实时作业监控JS */ var map = null; var marker = null; $(function() { // 百度地图API功能 map = new BMap.Map(\"allmap\", { enableMapClick:false }); map.centerAndZoom(\"重庆\", 13); map.addControl(new BMap.MapTypeControl({ mapTypes:[ BMAP_NORMAL_MAP, BMAP_SATELLITE_MAP, BMAP_HYBRID_MAP ]} )); map.enableScrollWheelZoom(true); // 添加比例尺控件 map.addControl(new BMap.ScaleControl()); // 初始化图标 $('#allmap div.anchorBL').hide() $(\"#search_button\").linkbutton({ text:'搜索', iconCls:'icon-search', onClick:function () { //获取参数 map.clearOverlays(); $.ajax({ url:'json/comment.json', method: \"post\", dataType: \"json\", data: params, async: false, success: function (data) { $.each(data.rows,function (i,obj) { if(obj.start_longitude){ doLocate(obj.start_longitude,obj.start_latitude,obj); } if(obj.end_longitude){ doLocate(obj.end_longitude,obj.end_latitude,obj); } }); } }); } }); }); function doLocate(jd, wd,data) {//根据经纬度定位 var point = new BMap.Point(jd, wd); marker = new BMap.Marker(point); map.addOverlay(marker); marker.enableDragging(); //启用标注拖动 if(data){ var taskId = data.trailer_task_id; var distance = data.distance; var opts = { width: 210, // 信息窗口宽度 height: 125, // 信息窗口高度 title: \"&lt;a href='javascript:;' onclick=\\\"generateTrack('\"+taskId+\"','\"+distance+\"')\\\"&gt;对应站点生成轨迹&lt;/a&gt;\", // 信息窗口标题 enableMessage: true, //设置允许信息窗发送短息 message: \"\" }; var content = \"起始地:\"+ data.start_place+\"&lt;br&gt;目的地:\"+data.end_place+ \"&lt;br&gt;经度:\" + jd + \"&lt;br&gt;纬度:\" + wd; var infoWindow = new BMap.InfoWindow(content, opts); // 创建信息窗口对象 marker.addEventListener(\"click\", function() { map.openInfoWindow(infoWindow, point); //开启信息窗口 }); } } function generateTrack(taskId,distance){ console.info(taskId); // 查询人员行进轨迹--画线 $.ajax({ url : \"json/location.json\", method : \"post\", dataType : \"json\", async : false, success : function (data) { // 添加个人轨迹 var points = []; var rows = data.rows; $.each(rows, function (i, obj) { var currentTaksId = rows[i].taskId; if(currentTaksId == taskId){ $.each(rows[i].data,function (j,data) { var point = new BMap.Point(data.longitude,data.latitude); points.push(point); if(j == 0){ map.setCenter(point); } }); $(\"#driver_naem\").html(rows[i].driverName); } }); var sy = new BMap.Symbol(BMap_Symbol_SHAPE_BACKWARD_OPEN_ARROW, { scale: 0.6, strokeColor:'#fff', strokeWeight: '2', }); var icons = new BMap.IconSequence(sy, '10', '10'); var polyline =new BMap.Polyline(points, { enableEditing: false, enableClicking: true, icons:[icons], strokeWeight:'8', strokeOpacity: 0.8, strokeColor:\"#ff5c34\" }); map.addOverlay(polyline); var juli = 0; for (let i = 0; i &lt; points.length; i++) { if(i == points.length -1){ break; } juli += getDistance(points[i],points[i+1]); } $(\"#current_mileage\").html(distance+\"/km\"); $(\"#latest_mileage\").html((Math.round(juli/100)/10).toFixed(1)+\"/km\"); } }); } function getDistance(startPoint, endPoint) { return map.getDistance(startPoint ,endPoint); }",
      "link": "/2020/04/19/b80605eb.html"
    },
    {
      "title": "springboot的java打印票据-4",
      "text": "java打印经过前几次的配置与解析，现在来说下java打印。java的api打印可以有字符串,画线，图片等。我们这里只用这两种。 1.打印字符串与图片来看下打印类的结构。&emsp;&emsp;这里在服务层初始化这个类。设置打印页数，xx.doPrint(类xx)。即可打印，他会执行两次print方法。在print方法中，参数 1.graphics - 用来绘制页面的上下文，即打印的图形； 2.pageFormat - 将绘制页面的大小和方向，即设置打印格式，如页面大小一点为计量单位（以1/72 英寸为单位，1英寸为25.4毫米。A4纸大致为595 × 842点）； 3.pageIndex - 要绘制的页面从 0 开始的索引 ，即页号。这里有两个参数，NO_SUCH_PAGE：从 print 返回，表示 pageindex 太大以及请求的页面不存在。PAGE_EXISTS：pageindex 指定请求页面从 0 开始的索引。如果请求的页面不存在，那么此方法将返回 no_such_page；否则返回 page_exists。说到这里是打印文字，下面说打印图片。 2.打印图片 1.首先引入谷歌的二维码依赖 &lt;!--gogle的Zxing生成二维码--&gt; &lt;!-- https://mvnrepository.com/artifact/com.google.zxing/core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.google.zxing/javase --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/dependency&gt; 然后创建生成二维码的工具类-QrCodeUtil。成员变量宽，高，内容。定义一个生成二维码的字节数组方法，然后以流的方式输出为图片。 public byte[] createQRCode() throws WriterException, IOException { // 二维码基本参数设置 Map&lt;EncodeHintType, Object&gt; hints = new HashMap&lt;EncodeHintType, Object&gt;(); hints.put(EncodeHintType.CHARACTER_SET, \"utf-8\");// 设置编码字符集utf-8 hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.Q);// 设置纠错等级L/M/Q/H,纠错等级越高越不易识别，当前设置等级为最高等级H hints.put(EncodeHintType.MARGIN, 0);// 可设置范围为0-10，但仅四个变化0 1(2) 3(4 5 6) 7(8 9 10) // 生成图片类型为QRCode BarcodeFormat format = BarcodeFormat.QR_CODE; // 创建位矩阵对象 BitMatrix bitMatrix = new MultiFormatWriter().encode(content, format, width, height, hints); // 设置位矩阵转图片的参数 //MatrixToImageConfig config = new MatrixToImageConfig(Color.black.getRGB(), Color.white.getRGB()); // 位矩阵对象转流对象 ByteArrayOutputStream os = new ByteArrayOutputStream(); MatrixToImageWriter.writeToStream(bitMatrix, \"png\", os); return os.toByteArray(); } 在printOrder中，获取字节数组，生成图片，然后java打印到纸上。 //先生成一个二维码图片 String strQRCode = printVo.getStrQRCode(); Integer qrcodeSize = printSettings.getQrcodeSize(); QrCodeUtil util = new QrCodeUtil(100,100,strQRCode); String name = \"\"; String orderCode = printVo.getOrderCode(); try { byte[] b = util.createQRCode(); name = printSettings.getBasePath()+orderCode+\".png\"; OutputStream os = new FileOutputStream(name); os.write(b); os.close(); }catch (Exception e){ logger.error(\"异常\",e); } //把图片画到上 try { File file=new File(name); if(!file.exists()){ file.mkdir(); } BufferedImage image = ImageIO.read(file); x0 = data.get(1).getX(); y0 = data.get(1).getY(); g2.drawImage(image,x0,y0,qrcodeSize,qrcodeSize,null); } catch (IOException e) { logger.error(\"获取二维码图像异常\",e); } 2.打印条形码引入依赖 &lt;dependency&gt; &lt;groupId&gt;net.sf.barcode4j&lt;/groupId&gt; &lt;artifactId&gt;barcode4j-light&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; 创建生成条形码的工具类，还是用字节流输出文件，不同的是 Code128Bean去描绘出条形码。在PrintTmOrder里面，去获取生成的文件，java画到纸上。 //第三行，条形码 String orderCode = printVo.getOrderCode(); String path = tmParameters.getPath();//参数路径 BarcodeUtil.generateFile(orderCode,path); //把图片画到上 try { File file=new File(path); if(!file.exists()){ file.mkdir(); } BufferedImage image = ImageIO.read(file); Integer x0 = tmParameters.getX(); Integer y0 = tmParameters.getY(); Integer width = tmParameters.getWidth(); Integer height = tmParameters.getHeight(); g2.drawImage(image,x0,y0,width,height,null); } catch (IOException e) { logger.error(\"获取二维码图像异常\",e); } 到此，java简单打印字符串，打印二维码、条形码图片完成。展示一下条形码：已经上传gitee，可以自行下载。",
      "link": "/2020/03/28/13dd02a9.html"
    },
    {
      "title": "itextpdf导出数据",
      "text": "这是一个导出数据为pdf的demo。 1.Maven种添入依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itext-asian&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt; 2.创建pdf工具类 3.组装数据进行填充和样式设置 创建PdfUtil1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.cargo.trailer.orderManage.vo;import com.itextpdf.text.*;import com.itextpdf.text.pdf.BaseFont;import com.itextpdf.text.pdf.PdfPCell;import com.itextpdf.text.pdf.PdfPTable;import com.itextpdf.text.pdf.PdfWriter;import me.javy.helper.Helper;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.net.URLEncoder;import java.util.List;/***填充数据--以日期空一行，列种不同的字段颜色不同*/public class PdfUtil { public static void exportPdf(HttpServletRequest request, HttpServletResponse response, List&lt;List&lt;String&gt;&gt; lists, String fileName) throws IOException,DocumentException { // 告诉浏览器用什么软件可以打开此文件 response.setHeader(\"content-Type\", \"application/pdf\"); // 导出文件的默认名称 response.setHeader(\"Content-Disposition\",\"attachment;fileName=\" + URLEncoder.encode(fileName + \".pdf\", \"UTF-8\")); BaseFont baseFont = BaseFont.createFont(\"STSongStd-Light\", \"UniGB-UCS2-H\", BaseFont.EMBEDDED); // 自定义字体属性 com.itextpdf.text.Font font = new com.itextpdf.text.Font(baseFont, 8); com.itextpdf.text.Font titleFont = new com.itextpdf.text.Font(baseFont, 10); Document document = new Document(new RectangleReadOnly(842F,595F));//a4纸横向 PdfWriter.getInstance(document, response.getOutputStream()); document.open();//文本开始 if (lists.size() &gt; 0 &amp;&amp; lists != null) { for (int i = 0; i &lt; lists.size(); i++) { PdfPTable table = new PdfPTable(lists.get(i).size()); table.setWidthPercentage(100);//table100% PdfPCell cell = new PdfPCell(); if (i == 0) { if (lists.get(i).size() &gt; 0 &amp;&amp; lists.get(i) != null) { for (int j = 0; j &lt; lists.get(i).size(); j++) { Paragraph p=new Paragraph(lists.get(i).get(j), titleFont); p.setFont(titleFont); // 水平居中 cell.setHorizontalAlignment(Element.ALIGN_CENTER); cell.setPhrase(p); cell.setBackgroundColor(new BaseColor(204, 204, 204)); // 文档中加入该段落 table.addCell(cell); document.add(table); } } }else { if (lists.get(i).size() &gt; 0 &amp;&amp; lists.get(i) != null) { for (int j = 0; j &lt; lists.get(i).size(); j++) { if(\"N\".equals(lists.get(i).get(j))){//不同日期之间空格 Paragraph blankRow4 = new Paragraph(18f, \" \", font); document.add(blankRow4); break; }else { Paragraph p=new Paragraph(lists.get(i).get(j),font); p.setFont(font); // 设置段落居中，其中1为居中对齐，2为右对齐，3为左对齐 //给外派上颜色 String field = lists.get(i).get(j); if(\"外派\".equals(field)){ PdfPCell wpCell = new PdfPCell(); wpCell.setBackgroundColor(new BaseColor(60,179,113)); wpCell.setHorizontalAlignment(Element.ALIGN_CENTER); wpCell.setPhrase(p); table.addCell(wpCell); document.add(table); continue; }else if(Helper.isNotEmpty(field) &amp;&amp; j == 3){ PdfPCell wpCell = new PdfPCell(); wpCell.setBackgroundColor(new BaseColor(255,255,0)); wpCell.setHorizontalAlignment(Element.ALIGN_CENTER); wpCell.setPhrase(p); table.addCell(wpCell); document.add(table); continue; }else{ cell.setHorizontalAlignment(Element.ALIGN_CENTER); cell.setPhrase(p); table.addCell(cell); document.add(table); } } } } } } document.close(); } }} 组装数据 1.日期不同之间空一行。用order by date asc 查询数据。载这行和下一行比较，若不同，则增加一个List 一个元素为N，用于之后填充时判断。 2.列的不同数据显示不同颜色。创建PdfPCell 对象，设置样式。 大约这样：",
      "link": "/2020/11/05/a3b4f1bf.html"
    },
    {
      "title": "安装elasticsearch的问题",
      "text": "1.cannot assign requested address:bind 安装elasticsearch5.5.2,配置了端口9200，让后启动。发生了这个错误；百度查询是绑定host出了问题。 解决问题[~#]vim elasticseach/config/elasticsearch.yml 增加两行 [~#]network.bind_host:127.0.0.1 [~#]network.publish_host:127.0.0.1 [~#]wq 启动成功",
      "link": "/2021/03/05/efa6925a.html"
    },
    {
      "title": "2023找工作记",
      "text": "2023找工作记3月13日​ 从重庆来到深圳，当天在翻身租了1600的房子(网费、管理费)。身上还剩下3000元。这是我找工作期间可以使用的全部资金，对于一个工作了几年的打工人，这点钱的确很少，人犯了错，就得受到惩罚，这个应该就是生活吧！ 3月31日​ 来深圳以经两周了，智联招聘上投递了上百家公司，没有一家面试。心里面有点着急，希望找个外包，boss上一直在聊，拉钩网也在投简历，总共也才10个面试左右，很多过了笔试，一面之后，二面就没有消息了。刚开始锁定南山区找工作，到了后面地域已经不限制了，珠海、广州、佛山等等，只要有面试的我都会考虑，依然没有找到工作。 4月1日​ 回想到去年4月1日从深圳回家，到现在，刚好一年。这一年经历了太多，思想上也发生了改变，不知道是认清了生活的真相，还是无能为力的妥协。好像今年我心里年龄变大了，可能是事情经历的多了吧，有了一些责任。 ​ 到了现在，我对今年的找工作持悲观态度，在认真找半个月，若还没有找到，我会先找一个能生存下来的工作，之后慢慢投简历找开发技术岗，也学习下目前招聘岗位需要的技术，弥补这一年的空缺。 总结​ 这世间只有一种英雄主义，那就是认清生活的真相后，依然热爱生活。",
      "link": "/2023/03/06/efa6925a.html"
    },
    {
      "title": "收集的计算机基础",
      "text": "收集的计算机基础推荐数据结构（李春葆）——我当时看的是书，没在网上看视频:https://www.bilibili.com/video/BV1oN411Q7Yz?share_source=copy_web计算机网络（谢希仁）——慕课哈工大（可以在B站或者慕课找到这个课程）计算机组成原理（唐朔飞/袁春风）——慕课上有袁春风的课，我看的是B站上的王道考研的课程：https://www.bilibili.com/video/BV1BE411D7ii?share_source=copy_web操作系统（汤小丹）——B站上的王道考研也有这个课程，讲得也挺明了、详细的：https://www.bilibili.com/video/BV1YE411D7nH?share_source=copy_web汇编语言（王爽）——bilibili：https://www.bilibili.com/video/BV1mt411R7Xv?share_source=copy_web 找电子书的网址（鸠摩）：https://www.jiumodiary.com/ 微信推荐计算机基础 计算机网络微课堂 https://www.bilibili.com/video/BV1c4411d7jb?p=1 学习计算机网络，我首先推荐的 UP 主湖科大教书匠，他讲的计算机网络十分通俗易懂，重点的地方讲的十分细致，并且还有一些实验，更好的是有考研 408 的难题的讲解，也是非常适合考研党，除了课程内容外还有很多习题讲解视频，特别赞的一点是每天动态里都会更新一道考研题，播放量也非常的多。 2019 王道考研 https://www.bilibili.com/video/BV19E411D78Q?p=1 既然说到了考研，那我就不得不提一下王道考研了，恭喜你发现了宝藏。王道考研的计算机网络视频，播放量非常多，而且老师是一位小姐姐，声音十分动听，声音这么好听的老师给你讲课，妈妈再也不用担心我的学习了呢，总之，这个视频的质量也非常高，弹幕全是对小姐姐的高度评价。（王道考研其他的视频也不错哦，暗示一下：操作系统，数据结构等等） 韩立刚老师 计算机网络 https://www.bilibili.com/video/BV1gV411h7r7?p=1 韩立刚老师所讲的计算机网络视频，内容比较多，但是讲解的通俗易懂，并且老师讲课的经验也十分的丰富。配套的教材是谢希仁老师的计算机网络教材，韩老师的最近的一个视频视频比较新，播放量还比较少，但是他讲的是真的不错，相比于王道考研所讲的计算机网络，韩老师更加细致一些。 计算机网络（谢希仁第七版）-方老师 https://www.bilibili.com/video/BV1yE411G7Ma?p=1 在计算机网络方面，我还想推荐的一位老师就是方老师，也是一位小姐姐老师。她的视频配套的教材也是谢老师的网络教材，在线看的小伙伴也超多，弹幕都是对方老师的评价。 数据结构二、数据结构与算法 相信很多小伙伴，学习数据结构、算法的时候，非常的头大，emmm…. 俺也一样。 【郝斌】-数据结构入门 https://www.bilibili.com/video/BV11s41167h6?p=1 我个人觉得他讲得非常好，郝斌老师的思路是以初学者的思路来思考的，非常适合小白，你不理解的问题，基本上他都会详细说一下，有的地方他讲的不是非常的全，但是讲的比较深刻，课程的使用的书是严蔚敏的《数据结构》可能比较晦涩难懂，可以去看看《大话数据结构》或者《啊哈！算法》这两本书。2. 数据结构-浙江大学 https://www.bilibili.com/video/BV1JW411i731?p=1 B站很多小伙伴都管陈越老师叫做陈越姥姥，陈姥姥的课简单易懂，二叉树和链表说的多，但是对于图太少，后面概念解释多程序少，对于新手不友好，并且这门课程到中后半段是另一位老师讲的，何老师。何老师讲解的也是非常的通俗易懂，并且拥有着强者的发型。 数据结构与算法基础（青岛大学-王卓） https://www.bilibili.com/video/BV1nJ411V7bd?p=1 王卓老师基本上把大学数据结构期末考试的重点全部都讲了，内容和 408 高度吻合，也是非常的适合考验人，还有在这里提一下王道考研的数据结构还是很不错的，总之学习数据结构重点还是需要理解，要多做题才行。 尚硅谷 Java 数据结构与 Java 算法（Java数据结构与算法） https://www.bilibili.com/video/BV1E4411H73v?p=1 推荐了这么多 C 语言的数据结构，就来一个了 Java 语言的吧。尚硅谷–韩顺平老师的课程，韩老师视频内容全，并且每次课都会带着你写代码，把每一个例子都会实现，这也是张阿姨梦开始的地方。韩老师的口碑我就不多说了，评论弹幕都是对韩老师的“表白”。 大雪菜 https://space.bilibili.com/7836741?spm_id_from=333.788.b_765f7570696e666f.1 给大家推荐一位关于 LeetCode 的大神，闫学灿老师，他的视频不仅会讲力扣的每日一题，还会讲解每一次力扣周赛的题目等等。你看就完了，yyds。 操作系统 [完结] 2020 南京大学 操作系统：设计与实现 (蒋炎岩) https://www.bilibili.com/video/BV1N741177F5?p=1 南大的课质量真的硬，蒋炎岩老师讲的是真滴好啊。老师讲课时用的课本是 Remzi 的 Operating Systems: Three Easy Pieces ，老师的每一节视频都比较长，一次肝完贼爽，老师把晦涩的东西讲的也非常的通俗易懂，豁然开朗，很多同学都是慕名而来，看完这个也算上过南大的操作系统啦 哈哈哈。 操作系统_清华大学(向勇、陈渝) https://www.bilibili.com/video/BV1js411b7vg?p=1 目前清华计算机系本科的操作系统课目前都是由这两位老师讲授(向勇、陈渝)，网课内容和他们课堂授课内容是一致的，同时配有一套完整的实验，实验内容是从无到有地建立起一个小却五脏俱全的操作系统（ucore），能从头到尾做下来的收获绝对是听课所不能比的，理论课上老师照顾大多数人，娓娓道来。现在有很多同学已经整理出了这门课程的随堂笔记，这门课程强烈推荐！ 操作系统（哈工大李治军老师） https://www.bilibili.com/video/BV1d4411v7u7?p=1 整体看了一遍，个人觉得是 b 站上很不错的操作系统课程了(经典课程如 mit6.828 在 b 站上的似乎都没有字幕而且拍摄角度实数刁钻)。这门课的前几讲涉及 OS 启动(老师谜之口糊)，需要一点汇编知识，不过遇到不会的直接网上搜即可，大可不必因为汇编而被劝退；之后的内容如多进程、信号量、内存管理等讲得很好，不做赘述。如果对这部分有不解的地方可以网上搜资料或者去看 b 站上新竹清华大学的 OS 课程最后在学这门课前建议对计算机有个整体认识，可以去学习一下经典的 csapp 或者 mit6.004(对应国内的计组，一个偏软件，一个偏硬件) 计算机组成原理 计算机组成原理（哈工大刘宏伟） https://www.bilibili.com/video/BV1t4411e7LH?p=1 刘宏伟老师主讲，他的课不仅适合考研人，也非常适合初学者，初学者也听得懂。建议 1.5 倍速食用。之前有一个一百多万播放量的视频，不知道为啥没了… 计算机组成原理 清华大学刘卫东https://www.bilibili.com/video/BV1c4411w7nd?p=1 来来来，清华的来了嗷，这门课是 2013 年的，距离 2021 年有点遥远。刘卫东老师主讲，质量很高。我非常喜欢他讲话的逻辑和风格，看就完了，贼好。（收藏是点赞的六倍还多，就离谱哈哈哈） 编译原理 编译原理（哈工大） https://www.bilibili.com/video/BV1zW411t7YE?p=1 陈鄞老师的 PPT 做的非常认真，讲得也很通俗易懂，思路清晰。这个是我目前为止，觉得讲的最直观简洁的了，全程没有一句废话，认真听会有很大的收获，每一句话都要仔细琢磨，并且老师那种温文尔雅的气质，你不认真听课？啊？小伙子。 认真学完真的会收获很多。",
      "link": "/2023/03/07/1ce21b5d.html"
    },
    {
      "title": "ElasticSearch7.10配置Search-Guard之配置用户",
      "text": "ElasticSearch7.10配置Search-Guard之配置用户 配置sg_internal_user.yml密码是：elastic 123456789101112131415161718192021222324252627jode: hash: $2y$12$nUzkcjdnufzvI1HlmN7xSuND3skGhmwV5le5IINejz.asMFpLYNRy backend_roles: - \"hr_department\"psmith: hash: $2y$12$nUzkcjdnufzvI1HlmN7xSuND3skGhmwV5le5IINejz.asMFpLYNRy backend_roles: - \"hr_department\"cmaddock: hash: $2y$12$nUzkcjdnufzvI1HlmN7xSuND3skGhmwV5le5IINejz.asMFpLYNRy backend_roles: - \"devops\" sg_roles.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445sg_human_resources: cluster_permissions:​ - \"SGS_CLUSTER_COMPOSITE_OPS\" index_permissions:​ - index_patterns:​ - \"humanresources\"​ allowed_actions:​ - \"SGS_READ\"sg_devops: cluster_permissions:​ - \"SGS_CLUSTER_COMPOSITE_OPS\" index_permissions:​ - index_patterns:​ - \"infrastructure\"​ allowed_actions:​ - \"SGS_READ\"​ - \"SGS_WRITE\"​ - index_patterns:​ - \"logs-*\"​ allowed_actions:​ - \"SGS_READ\" sg_roles_mapping.yml12345678910111213sg_human_resources: backend_roles:​ - \"hr_department\"sg_devops: backend_roles:​ - \"devops\" sgadmin命令12345678910111213./sgadmin.sh -cd ../sgconfig/ -cert /home/software/es_ssl/es/config/certs/kirk.crtfull.pem-key /home/software/es_ssl/es/config/certs/kirk.key.pem -cacert /home/software/es_ssl/es/config/certs/root-ca.pem -keypass changeit -nhnv -icl 创建索引（1）用jode 去创建索引、删除索引 去查询除了humanresources索引之外的索引 （2）用cmaddock 去创建索引、删除索引 去查询infrastructure索引、写入数据 去查询log开头的索引、写入 查询、写入其他索引 jode操作创建索引 返回来的异常信息，为admin才能创建索引，失败了。 创建文档123456789{​ \"username\":\"张三\",​ \"age\":18,​ \"gender\":\"male\"} 以经用admin创建了*humanresources索引，现在用jode用户去写入数据，明显无权限，由于jode属于hr_department角色，只能有查询*humanresources**的权限 查询索引查询humanresources索引，能查询出数据。 我现在用jode用户，查询infrastructure索引，显示无权限。 cmaddock操作cmaddock是devops角色的用户，有两个索引，其中infrasturcture可以读和写的权限，logs-*只可以读 创建索引 显然是无权限，正确。 创建文档 显示成功，正确 对于logs-*索引，无写权限，如下： 查询索引infrastructure索引 显示数据，成功。 logs-*索引我创建了logs-2023、log-2023两个索引。 查询log-2023 显示无权限，正确，由于对于logs-*正则表达式的索引，才能查询。 查询logs-2023 显示数据，成功",
      "link": "/2023/03/06/efa6925a.html"
    }
  ],
  "tags": [
    {
      "name": "Python",
      "slug": "Python",
      "link": "/tags/Python/"
    },
    {
      "name": "nodeJs",
      "slug": "nodeJs",
      "link": "/tags/nodeJs/"
    },
    {
      "name": "SpringBoot",
      "slug": "SpringBoot",
      "link": "/tags/SpringBoot/"
    }
  ],
  "categories": [
    {
      "name": "WEB",
      "slug": "WEB",
      "link": "/categories/WEB/"
    },
    {
      "name": "Python",
      "slug": "Python",
      "link": "/categories/Python/"
    },
    {
      "name": "人生",
      "slug": "人生",
      "link": "/categories/%E4%BA%BA%E7%94%9F/"
    },
    {
      "name": "Life",
      "slug": "Life",
      "link": "/categories/Life/"
    },
    {
      "name": "服务器",
      "slug": "服务器",
      "link": "/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"
    },
    {
      "name": "Novel",
      "slug": "Novel",
      "link": "/categories/Novel/"
    },
    {
      "name": "Redis",
      "slug": "Redis",
      "link": "/categories/Redis/"
    },
    {
      "name": "SpringBoot",
      "slug": "SpringBoot",
      "link": "/categories/SpringBoot/"
    },
    {
      "name": "Elastic",
      "slug": "Elastic",
      "link": "/categories/Elastic/"
    },
    {
      "name": "JS",
      "slug": "JS",
      "link": "/categories/JS/"
    },
    {
      "name": "Git",
      "slug": "Git",
      "link": "/categories/Git/"
    }
  ]
}