{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"","text":"关于我大家好，我是山沉，这是我建的第一个博客。现在是java+微服务路上的行者，希望我们共同上路，一路前行。 我的站点 博客园：山沉 CSDN：山沉 思否：山沉 掘金：山沉","link":"/about/index.html"}],"posts":[{"title":"ie浏览器的加载js不了的问题","text":"2020年3月13日工作问题问题：在jsp页面，下有js文件没有加载出来，但是在f12下，刷新就加载出来了。 我打开的网页是360安全浏览器，内核设置为ie8，但是打开网页有一些js文件就是加载不出来，后来查询 得知。在ie8/9模式下，只能打开f12生效console方法。在ie6/7，根本没有这个方法。 解决： 1.直接一点，删除就可以了 2.用代码解决 if(window.console){ //一些console命令 console.info(&quot;gogo&quot;)； }这次的问题发生了，及时的解决，才能更好的锻炼自己。","link":"/2020/03/13/313-ie/"},{"title":"Postgresql导出数据字典","text":"这是在工作中，有时会遇到的问题，要求完善数据字典。这里是python导出Postgresql表的字典，仅供参考。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161import psycopg2import xlwtfrom datetime import datetimeimport os def getData(): conn = psycopg2.connect(database='数据库名', user='postgres', password='密码', host='127.0.0.1', port=5432) cur = conn.cursor() query = ''' SELECT d.relname AS relname, obj_description ( relfilenode, 'pg_class' ) AS tablename, attname AS field,CASE typname WHEN '_bpchar' THEN 'char' WHEN '_varchar' THEN 'varchar' WHEN '_date' THEN 'date' WHEN '_float8' THEN 'float8' WHEN '_int4' THEN 'int4' WHEN '_int8' THEN 'int8' WHEN '_interval' THEN 'interval' WHEN '_numeric' THEN 'numeric' WHEN '_float4' THEN 'float4' WHEN '_int2' THEN 'smallint' WHEN '_text' THEN 'text' WHEN '_time' THEN 'time' WHEN '_timestamp' THEN 'timestamp' WHEN '_timestamptz' THEN 'timestamptz' END AS TYPE, CASE typname WHEN '_bpchar' THEN atttypmod - 4 WHEN '_varchar' THEN atttypmod - 4 WHEN '_numeric' THEN ( atttypmod - 4 ) / 65536 ELSE attlen END AS LENGTH, CASE typname WHEN '_numeric' THEN ( atttypmod - 4 ) % 65536 ELSE 0 END AS xs,CASE WHEN b.attnotnull = 't' THEN '不能为空' ELSE'' END AS NOTNULL,CASE WHEN ( SELECT COUNT ( * ) FROM pg_constraint WHERE conrelid = b.attrelid AND conkey [ 1 ]= attnum AND contype = 'p' ) &gt; 0 THEN '主键' ELSE'' END AS zj ,col_description ( b.attrelid, b.attnum ) AS COMMENTFROM pg_stat_user_tables AS A, pg_class AS d, pg_tables AS P, pg_attribute AS b, pg_type AS CWHERE A.relid = b.attrelid AND b.attnum &gt; 0 AND b.atttypid = C.typelem AND substr( typname, 1, 1 ) = '_' AND P.tablename = d.relname AND d.relname = A.relname AND A.relname NOT LIKE'c%' AND A.relname NOT LIKE'S%'ORDER BY A.schemaname, A.relname,attnum ''' cur.execute(query) data = cur.fetchall() conn.commit() cur.close() conn.close() return data def queryDataToExcel(name): data = getData() myExcel = xlwt.Workbook('encoding=utf-8') # 查询二原数据采集量 sheet1 = myExcel.add_sheet(name, cell_overwrite_ok=True) sheet1.col(0).width = 150 * 20 sheet1.col(1).width = 150 * 20 sheet1.col(2).width = 150 * 20 sheet1.col(3).width = 150 * 20 sheet1.col(4).width = 150 * 20 sheet1.col(5).width = 150 * 20 sheet1.col(6).width = 150 * 20 sheet1.col(7).width = 150 * 20 sheet1.col(8).width = 150 * 20 sheet1.col(8).width = 350 * 20 #设置居中 a1 = xlwt.Alignment() a1.horz = 0x02 a1.vert = 0x01 style = xlwt.XFStyle() # 赋值style为XFStyle为初始化样式 style.alignment = a1 today = datetime.today() # 获取当前日期，得到一个datetime对象如：(2019, 7, 2, 23, 12, 23, 424000) today_date = datetime.date(today) # 将获取到的datetime对象仅取日期如：2019-7-2 items = ['数据表', '表名', '字段', '类型', '长度', '小数点', '是否为空', '是否为主键', '注释'] for col in range(len(items)): sheet1.write(0, col, items[col]) # 从data获取第一列数据，[(&quot;xxx&quot;,&quot;xxx&quot;),()] first_col = [] for i in range(len(data)): first_col.append(data[i][0]) print(&quot;first_col:&quot;, first_col) # 去掉重复的列数据，并顺序不变 nFirst_col = list(set(first_col)) nFirst_col.sort(key=first_col.index) print(&quot;nFirst_col:&quot;, nFirst_col) row = 1 for i in nFirst_col: count = first_col.count(i) # 计算重复的元素个数 mergeRow = row + count - 1 # 合并后的上行数， sheet1.write_merge(row, mergeRow, 0, 0, i, style) # 第一列 sheet1.write_merge(row, mergeRow, 1, 1, i, style) row = mergeRow + 1 # 从下一行开始写入 # 获取data[i]中的第二个元素，循环写入 for row in range(len(data)): for col in range(1, len(data[row])): sheet1.write(row + 1, col, data[row][col], style) fileName = name + '_' + str(today_date) + '.xls' rootPath = os.path.dirname(os.path.abspath(_file_))+'\\\\' print(rootPath) flag = os.path.exists(rootPath+fileName) if flag: os.remove(rootPath+fileName) myExcel.save(fileName) else: myExcel.save(fileName) # 以传递的name+当前日期作为excel名称保存 if __name__ == '__main__': print(&quot;这是从postgresql中导出excel的demo----&quot;) queryDataToExcel(&quot;数据表&quot;) 这里我用的是xlwt，没用openpyxl操作","link":"/2020/03/07/ExportTable/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/06/hello-world/"},{"title":"hexo+icarus搭建的第一个博客","text":"博客的搭建过程中，才发现自己会的东西挺少。今后会继续学习，持之以恒，参考了的一些资料，总算搭建了一个hexo+icarus实现的博客。 所需内容 github账户一个 nodejs安装(之后在安装hexo等) git for windows 0.申请一个github账户注册账户，完成之后生成一个GitHub的 ID.github.io的仓库。这个在之后上传静态资源，可以作为默认网址访问博客。 1.nodejs安装这里不过多的叙述，或者在网上找资料，普通的安装。 2.hexo+icarus搭建博客&emsp;这里推荐小明同学的博客，丰富的记录了hexo搭建博客的所需事项。当时域名的绑定与配置没有搞清楚，后来配置域名时，才知道在国内注册的域名要备案，后来又去备案，结果没有备案，照下面这样做，也能访问。(最好备案，各个网站的app备案更快.) 3.配置华为云域名 在项目的source目录下建一个没有后缀的文件-CNAME，里面写入www.xxx.xx你的域名。 123hexo cleanhexo generatehexo deploy 只要过2到3分中即可用域名访问了。OK！","link":"/2020/03/07/hexo%E6%90%AD%E5%BB%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"},{"title":"nodejs启动服务失败","text":"nodejs启动服务过程中难免遇到一些问题，此次我就遇到了node-sass安装后环境发生变化的问题。 1.第一次提示This usually happens because your environment has changed since running npm install百度说是node-sass安装后环境发生变化。需要重新编译或安装node-sass 解决 1.在项目根路径打开管理员模式的cmd 2 npm rebuild node-sass 2.1 提示Cannot download “https://github.com/sass/node-sass/releases/download/v4.13.1/win32-x64-72_binding.node&quot;: 3.设置淘宝下载 npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ ok,启动node服务成功","link":"/2020/03/07/nodejs/"},{"title":"Life/Sql1","text":"title: 分享一个sql查询重复记录date: 2020-03-31 23:04tags:categories: Life postgres的查询重复sql记录select bill_code,count(1) from t_fee_agencyfee_bill GROUP BY bill_code HAVING count(*) &gt; 1 group by 根据前面查询的字段来分组的。工作中会用到的。","link":"/2020/03/31/Life/Sql1/"},{"title":"今天复工，维护好累","text":"维护今天的工作&emsp;今天是我第一次正式维护工作，深知不易。代码可能没有几行，但大多数是在找前人写代码的漏洞，当然是客户给我们找到的。找寻bug很费劲，还原bug更费劲。我大量的时间在跟客户交流，没有几行代码输出，有很大一部分的原因是眉毛胡子一把抓，没有分清主次，搞得很疲惫。&emsp;提高自己的技术，还是重中之重，没有比自己肚子里有货更重要，今天开始学习松哥的springboot系列教程，希望自己可以得到提高。 如何提高自己&emsp;尽量多学习一点。尽量不气馁。尽量跟进时局。今天学习一点markdown的知识： 123半方大的空白&amp;ensp;或&amp;#8194;全方大的空白&amp;emsp;或&amp;#8195;不断行的空白格&amp;nbsp;或&amp;#160;","link":"/2020/03/16/Life/2020%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%85%AC%E5%8F%B8%E4%B8%8A%E7%8F%AD/"},{"title":"Python导出SqlServer数据字典","text":"定义三个方法1.定义一个获取数据的getData()方法2.定义一个导出excel表的方法exportSqlServer()3.定义一个获取类型typeof()的方法，用作查询出来的数据被识别 下面直接展示代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147from datetime import datetimeimport osimport pymssql as pymssqlimport xlwtdef getData(): connect= pymssql.connect(host, 'sa', 密码, 数据库名); cur = connect.cursor(); query = ''' SELECT tableName = D.name , # 我合并单元格是按照这里的表的重复合并的，若用case whern end 结构，则不能合并，会出错 tableIntroduce = isnull(F.value,''), sort = A.colorder, fieldName = A.name, catogary = B.name, bytes = A.Length, lengths = COLUMNPROPERTY(A.id,A.name,'PRECISION'), scales = isnull(COLUMNPROPERTY(A.id,A.name,'Scale'),0), isOrNotNull = Case When A.isnullable=1 Then '√'Else '' End, primarays = Case When exists(SELECT 1 FROM sysobjects Where xtype='PK' and parent_obj=A.id and name in ( SELECT name FROM sysindexes WHERE indid in( SELECT indid FROM sysindexkeys WHERE id = A.id AND colid=A.colid))) then '√' else '' end, defauts = isnull(E.Text,''), annotations = isnull(G.[value],'') FROM syscolumns A Left Join systypes B On A.xusertype=B.xusertype Inner Join sysobjects D On A.id=D.id and D.xtype='U' and D.name&lt;&gt;'dtproperties' Left Join syscomments E on A.cdefault=E.id Left Join sys.extended_properties G on A.id=G.major_id and A.colid=G.minor_id Left Join sys.extended_properties F On D.id=F.major_id and F.minor_id=0 --where d.name='OrderInfo' --如果只查询指定表,加上此条件 Order By A.id,A.colorder''' cur.execute(query) data = cur.fetchall() # 元组类型 return datadef exportExcel(name): data = getData() myExcel = xlwt.Workbook('encoding=utf-8') # 定义表的宽 sheet1 = myExcel.add_sheet(name, cell_overwrite_ok=True) sheet1.col(0).width = 300 * 20 sheet1.col(1).width = 400 * 20 sheet1.col(2).width = 100 * 20 sheet1.col(3).width = 300 * 20 sheet1.col(4).width = 256 * 20 sheet1.col(5).width = 180 * 20 sheet1.col(6).width = 180 * 20 sheet1.col(7).width = 100 * 20 sheet1.col(8).width = 100 * 20 sheet1.col(9).width = 100 * 20 sheet1.col(10).width = 180 * 20 sheet1.col(11).width = 800 * 20 # 设置居中 a1 = xlwt.Alignment() a1.horz = 0x02 a1.vert = 0x01 style = xlwt.XFStyle() # 赋值style为XFStyle为初始化样式 style.alignment = a1 today = datetime.today() # 获取当前日期，得到一个datetime对象如：(2019, 7, 2, 23, 12, 23, 424000) today_date = datetime.date(today) # 将获取到的datetime对象仅取日期如：2019-7-2 items = ['数据表', '表名', '字段序号', '字段', '类型', '占用字节数', '长度', '小数点', '是否为空', '是否为主键', '默认值','注释'] for col in range(len(items)): sheet1.write(0, col, items[col]) # 合并第二列的name,从content获取第一列数据，[(&quot;Choleen&quot;,&quot;xxx&quot;),()] first_col = [] for i in range(len(data)): first_col.append(data[i][0]) print(&quot;first_col:&quot;, first_col) # 去掉重复的列数据，并顺序不变 nFirst_col = list(set(first_col)) nFirst_col.sort(key=first_col.index) print(&quot;nFirst_col:&quot;, nFirst_col) row = 1 for i in nFirst_col: count = first_col.count(i) # 计算重复的元素个数 mergeRow = row + count - 1 # 合并后的上行数， sheet1.write_merge(row, mergeRow, 0, 0, i, style) # 第一列 sheet1.write_merge(row, mergeRow, 1, 1, i, style) row = mergeRow + 1 # 从下一行开始写入 # 获取data[i]中的第二个元素，循环写入 for row in range(len(data)): for col in range(1, len(data[row])): result = data[row][col] str = typeof(result) # 获取类型 if str == None: # 不能识别的类型，需要转换 result = result.decode('utf-8') sheet1.write(row + 1, col, result, style) fileName = name + '.xls' rootPath = os.path.dirname(os.path.abspath('ExportSqlServer.py')) + '\\\\' print(rootPath) flag = os.path.exists(rootPath + fileName) if flag: os.remove(rootPath + fileName) myExcel.save(fileName) else: myExcel.save(fileName) def typeof(variate): type = None if isinstance(variate, int): type = &quot;int&quot; elif isinstance(variate, str): type = &quot;str&quot; elif isinstance(variate, float): type = &quot;float&quot; elif isinstance(variate, list): type = &quot;list&quot; elif isinstance(variate, tuple): type = &quot;tuple&quot; elif isinstance(variate, dict): type = &quot;dict&quot; elif isinstance(variate, set): type = &quot;set&quot; return typeif __name__ == '__main__': print(&quot;这是sqlServer导出的数据字典&quot;); # response = chardet.detect(b'\\xe7\\x94\\xa8\\xe6\\x88\\xb7\\xe8\\xa1\\xa8') # print(response) exportExcel(&quot;user表&quot;) 在编写代码过程中出现了，中文乱码。python3会自动转换未unicode，我们来看下转换过程： 1234567 UTF-8/GBK --》 decode 解码 --》 Unicode Unicode --》 encode 编码 --》 GBK / UTF-8 ``` 这里的代码是Unicode,要转换成明文，就需要decode方法，只能是unicode的格式才能，若是int，str类型则会报错 ```angular2html明文 -- encode --》Unicode--》gbk，utf-8明文 《-- decode -- Unicode 《-- gbk，utf-8 so，这样就可以了。完成。","link":"/2020/03/17/Python/Python%E5%AF%BC%E5%87%BAsqlServer%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8/"},{"title":"Life/吾日三省","text":"吾日三省","link":"/2020/04/29/Life/%E5%90%BE%E6%97%A5%E4%B8%89%E7%9C%81/"},{"title":"迎难而上","text":"###生活本苦，奈何年华我们再物欲横流的今天，静下心来想一想，生活再人的一生中是什么？我到底该去向那里。 1.生活中的双人格&emsp;看了电视剧余欢水，我真切的感受到人的一天真的可以有很多中活法。在工作中，我们也可以做自己。规则之下，我们也要作乐。2.不断的学习&emsp;社会在发展，科技在进步，我们也要时刻提升自己，不光学识，内在也要丰富。","link":"/2020/04/26/Life/%E8%BF%8E%E9%9A%BE%E8%80%8C%E4%B8%8A/"},{"title":"springboot的java打印票据-2","text":"Java打印之httpClient服务前面我们配置了httpClient实例，现在我们配置服务，我们配置get和post请求，用于之后的请求。1.注入实例时，若required没有或是ture则都是默认有这个实例的，不然肯定失败! @Service public class HttpClientService { @Autowired(required=false) private CloseableHttpClient httpClient; @Autowired(required=false) private RequestConfig config; } 1.这里我们首先编写get请求不带参数，如果状态码200，则会返回body，若不是200，则返回null。 public String doGet(String url) throws Exception { // 声明 http get 请求 HttpGet httpGet = new HttpGet(url); // 装载配置信息 httpGet.setConfig(config); // 发起请求 CloseableHttpResponse response = this.httpClient.execute(httpGet); // 判断状态码是否为200 if (response.getStatusLine().getStatusCode() == 200) { // 返回响应体的内容 return EntityUtils.toString(response.getEntity(), \"UTF-8\"); } return null; } 2.然后编写get带参数的请求。这里的带参结构都是map结构，我们可以引入解析json字符串为实体的依赖。 public String doGet(String url, Map&lt;String, Object&gt; map) throws Exception { URIBuilder uriBuilder = new URIBuilder(url); if (map != null) { // 遍历map,拼接请求参数 for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) { uriBuilder.setParameter(entry.getKey(), entry.getValue().toString()); } } // 调用不带参数的get请求 return this.doGet(uriBuilder.build().toString()); } 3.设置带参数的post请求 public HttpResult doPost(String url, Map&lt;String, Object&gt; map) throws Exception { // 声明httpPost请求 HttpPost httpPost = new HttpPost(url); // 加入配置信息 httpPost.setConfig(config); // 判断map是否为空，不为空则进行遍历，封装from表单对象 if (map != null) { List&lt;NameValuePair&gt; list = new ArrayList&lt;NameValuePair&gt;(); for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) { list.add(new BasicNameValuePair(entry.getKey(), entry.getValue().toString())); } // 构造from表单对象 UrlEncodedFormEntity urlEncodedFormEntity = new UrlEncodedFormEntity(list, \"UTF-8\"); // 把表单放到post里 httpPost.setEntity(urlEncodedFormEntity); } // 发起请求 CloseableHttpResponse response = this.httpClient.execute(httpPost); return new HttpResult(response.getStatusLine().getStatusCode(), EntityUtils.toString( response.getEntity(), \"UTF-8\")); } 4.不带参数的请求 public HttpResult doPost(String url) throws Exception { return this.doPost(url, null); } 5.还可以是json格式的参数，进行post请求 public String doPostJson(String url, String json) throws Exception { // 创建http POST请求 HttpPost httpPost = new HttpPost(url); httpPost.setConfig(config); if(null != json){ //设置请求体为 字符串 StringEntity stringEntity = new StringEntity(json,\"UTF-8\"); httpPost.setEntity(stringEntity); } CloseableHttpResponse response = null; try { // 执行请求 response = httpClient.execute(httpPost); // 判断返回状态是否为200 if (response.getStatusLine().getStatusCode() == 200) { return EntityUtils.toString(response.getEntity(), \"UTF-8\"); } } finally { if (response != null) { response.close(); } } return null; } 到此，我们就把httpClient设置好了。要在那里使用直接注入@Autowired。 logger日志配置在项目中，我们会发生很多异常，和需要打印信息。这里就要配置日志了。在properties中我们配置一些基础信息： # 日志文件 logging.file.path=D:/logs/PrintLog/ #文件路径 logging.file.name=Print.log # 文件名 logging.file.max-size=100MB #文件定义最大的大小 logging.file.max-history=7 # 日志保存的最长时间 logging.config=classpath:logging-config.xml #配置文件路径 1.配置logging-config.xml，里面有几个节点。logback配置之Configuration。中有几个属性。其中： 1.scan：属性为true，文件发生改变，将会重新加载，defaut=true 2.scanPeriod –字面意思扫描时间段，设置监测配置文件是否有时间间隔，没有给出具体时间间隔，单位毫秒，默认为1分钟。 3.debug 属性为true时，将打印出logback的内部日志信息，默认为false。 2.Configuration的子节点： 1.contextName 上下文名称。用于区分不同的程序记录，默认为defaut，这里没有配置，一旦配置，便不能修改 2.变量property，有name和value属性，设置之后可以在上下文中${name}使用这里只配置root，使用appender进行输出日志文件及内容 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;configuration debug=\"false\"&gt; &lt;!--设置存储路径变量--&gt; &lt;property name=\"LOG_HOME\" value=\"D:/logs/PrintLog/\"/&gt; &lt;!--控制台输出appender--&gt; &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!--设置输出格式--&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;!--设置编码--&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--文件输出,时间窗口滚动--&gt; &lt;appender name=\"timeFileOutput\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!--日志名,指定最新的文件名，其他文件名使用FileNamePattern --&gt; &lt;File&gt;${LOG_HOME}/jiuluPrint.log&lt;/File&gt; &lt;!--文件滚动模式--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!--日志文件输出的文件名,可设置文件类型为gz,开启文件压缩--&gt; &lt;FileNamePattern&gt;${LOG_HOME}/info.%d{yyyy-MM-dd}.%i.log.gz&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数--&gt; &lt;MaxHistory&gt;7&lt;/MaxHistory&gt; &lt;!--按大小分割同一天的--&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;!--输出格式--&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;!--设置编码--&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--指定基础的日志输出级别--&gt; &lt;root level=\"INFO\"&gt; &lt;!--appender将会添加到这个loger--&gt; &lt;appender-ref ref=\"console\"/&gt; &lt;appender-ref ref=\"timeFileOutput\"/&gt; &lt;/root&gt; &lt;/configuration&gt; 这样启动之后就会在设置路径下生成日志文件了。启动之后就会更替默认的日志格式。个人博客:山沉CSDN博客园","link":"/2020/03/26/Work/JavaPrint2/"},{"title":"springboot的java打印票据","text":"Java打印的几个步骤 1构建springboot框架 2引入log日志 3构建java打印xml文件 4解析xml配置文件 5java打印 由于需要，现在要实现一个java打印的程序。我们开始第一步构建springboot项目。 第一步打开idea，new 一个Project，选择Spring initializr 初始化一个springboot项目。在pom文件中按下alt + insert 选择Dependency使用idea的引入maven依赖。如下： &lt;!--基础依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--httpClient连接--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--gogle的Zxing生成二维码--&gt; &lt;!-- https://mvnrepository.com/artifact/com.google.zxing/core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.google.zxing/javase --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--判断非空等的工具依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;me.javy&lt;/groupId&gt; &lt;artifactId&gt;javy-helper&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--使用pojo解析xml文件所用--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;/dependency&gt; 下面是我的类结构图：配置httpClient 1.httpClient连接可以远程访问服务器，获取数据，有时需要。所以这里也配一下。下面我们进行httpClient配置。在config包下建一个httpClient和httpCLientService，一个是构建对象一个是连接服务。在properties中写入httpclient的基础配置： #http配置服务 #最大连接数 http.maxTotal = 100 #并发数 http.defaultMaxPerRoute = 20 #创建连接的最长时间 http.connectTimeout=1000 #从连接池中获取到连接的最长时间 http.connectionRequestTimeout=500 #数据传输的最长时间 http.socketTimeout=10000 #提交请求前测试连接是否可用 http.staleConnectionCheckEnabled=true 2.在httpClient往容器中注入Bean属性，采用注解@Value来实现如下： @Configuration public class HttpClient { @Value(&quot;${http.maxTotal:1}&quot;) private Integer maxTotal; @Value(&quot;${http.defaultMaxPerRoute:1}&quot;) private Integer defaultMaxPerRoute; @Value(&quot;${http.connectTimeout:1}&quot;) private Integer connectTimeout; @Value(&quot;${http.connectionRequestTimeout:1}&quot;) private Integer connectionRequestTimeout; @Value(&quot;${http.socketTimeout:1}&quot;) private Integer socketTimeout; @Value(&quot;${http.staleConnectionCheckEnabled:true}&quot;) private boolean staleConnectionCheckEnabled; } 1.下面我们首先实列化一个连接池管理器，设置最大连接数，并发连接数。 @Bean(name = &quot;httpClientConnectionManager&quot;) public PoolingHttpClientConnectionManager getHttpClientConnectionManager(){ PoolingHttpClientConnectionManager httpClientConnectionManager = new PoolingHttpClientConnectionManager(); //最大连接数 httpClientConnectionManager.setMaxTotal(maxTotal); //并发数 httpClientConnectionManager.setDefaultMaxPerRoute(defaultMaxPerRoute); return httpClientConnectionManager; } 2.实列化连接池，设置连接池管理器。我们需要用到spring的@Qualifier，其意为合格者，用于区分注解实例，参数名为我们的连接池管理器注解名称。 @Bean(name = &quot;httpClientBuilder&quot;) public HttpClientBuilder getHttpClientBuilder(@Qualifier(&quot;httpClientConnectionManager&quot;)PoolingHttpClientConnectionManager httpClientConnectionManager){ //HttpClientBuilder中的构造方法被protected修饰，所以这里不能直接使用new来实例化一个HttpClientBuilder，可以使用HttpClientBuilder提供的静态方法create()来获取HttpClientBuilder对象 HttpClientBuilder httpClientBuilder = HttpClientBuilder.create(); httpClientBuilder.setConnectionManager(httpClientConnectionManager); return httpClientBuilder; } 3.注入连接池，获取client对象 @Bean public CloseableHttpClient getCloseableHttpClient(@Qualifier(&quot;httpClientBuilder&quot;) HttpClientBuilder httpClientBuilder){ return httpClientBuilder.build(); } 4.Builder是requestConfig中的一个内部类，通过requestConfig的custom方法获取builder的对象，设置builder的连接信息。 @Bean(name = &quot;builder&quot;) public RequestConfig.Builder getBuilder(){ RequestConfig.Builder builder = RequestConfig.custom(); return builder.setConnectTimeout(connectTimeout)//创建连接的最长时间 .setConnectionRequestTimeout(connectionRequestTimeout)//从连接池中获取的连接最长时间 .setSocketTimeout(socketTimeout)//数据传输的最长时间 .setStaleConnectionCheckEnabled(staleConnectionCheckEnabled);//提交请求前测试连接是否可用 } 5.用builder构建一个requestConfig对象 @Bean public RequestConfig getRequestConfig(@Qualifier(&quot;builder&quot;) RequestConfig.Builder builder){ return builder.build(); } 到此httpclient基础信息初始化配置完成。","link":"/2020/03/25/Work/JavaPrint/"},{"title":"springboot的java打印票据-4","text":"java打印经过前几次的配置与解析，现在来说下java打印。java的api打印可以有字符串,画线，图片等。我们这里只用这两种。 1.打印字符串与图片来看下打印类的结构。&emsp;&emsp;这里在服务层初始化这个类。设置打印页数，xx.doPrint(类xx)。即可打印，他会执行两次print方法。在print方法中，参数 1.graphics - 用来绘制页面的上下文，即打印的图形； 2.pageFormat - 将绘制页面的大小和方向，即设置打印格式，如页面大小一点为计量单位（以1/72 英寸为单位，1英寸为25.4毫米。A4纸大致为595 × 842点）； 3.pageIndex - 要绘制的页面从 0 开始的索引 ，即页号。这里有两个参数，NO_SUCH_PAGE：从 print 返回，表示 pageindex 太大以及请求的页面不存在。PAGE_EXISTS：pageindex 指定请求页面从 0 开始的索引。如果请求的页面不存在，那么此方法将返回 no_such_page；否则返回 page_exists。说到这里是打印文字，下面说打印图片。 2.打印图片 1.首先引入谷歌的二维码依赖 &lt;!--gogle的Zxing生成二维码--&gt; &lt;!-- https://mvnrepository.com/artifact/com.google.zxing/core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.google.zxing/javase --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/dependency&gt; 然后创建生成二维码的工具类-QrCodeUtil。成员变量宽，高，内容。定义一个生成二维码的字节数组方法，然后以流的方式输出为图片。 public byte[] createQRCode() throws WriterException, IOException { // 二维码基本参数设置 Map&lt;EncodeHintType, Object&gt; hints = new HashMap&lt;EncodeHintType, Object&gt;(); hints.put(EncodeHintType.CHARACTER_SET, \"utf-8\");// 设置编码字符集utf-8 hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.Q);// 设置纠错等级L/M/Q/H,纠错等级越高越不易识别，当前设置等级为最高等级H hints.put(EncodeHintType.MARGIN, 0);// 可设置范围为0-10，但仅四个变化0 1(2) 3(4 5 6) 7(8 9 10) // 生成图片类型为QRCode BarcodeFormat format = BarcodeFormat.QR_CODE; // 创建位矩阵对象 BitMatrix bitMatrix = new MultiFormatWriter().encode(content, format, width, height, hints); // 设置位矩阵转图片的参数 //MatrixToImageConfig config = new MatrixToImageConfig(Color.black.getRGB(), Color.white.getRGB()); // 位矩阵对象转流对象 ByteArrayOutputStream os = new ByteArrayOutputStream(); MatrixToImageWriter.writeToStream(bitMatrix, \"png\", os); return os.toByteArray(); } 在printOrder中，获取字节数组，生成图片，然后java打印到纸上。 //先生成一个二维码图片 String strQRCode = printVo.getStrQRCode(); Integer qrcodeSize = printSettings.getQrcodeSize(); QrCodeUtil util = new QrCodeUtil(100,100,strQRCode); String name = \"\"; String orderCode = printVo.getOrderCode(); try { byte[] b = util.createQRCode(); name = printSettings.getBasePath()+orderCode+\".png\"; OutputStream os = new FileOutputStream(name); os.write(b); os.close(); }catch (Exception e){ logger.error(\"异常\",e); } //把图片画到上 try { File file=new File(name); if(!file.exists()){ file.mkdir(); } BufferedImage image = ImageIO.read(file); x0 = data.get(1).getX(); y0 = data.get(1).getY(); g2.drawImage(image,x0,y0,qrcodeSize,qrcodeSize,null); } catch (IOException e) { logger.error(\"获取二维码图像异常\",e); } 2.打印条形码引入依赖 &lt;dependency&gt; &lt;groupId&gt;net.sf.barcode4j&lt;/groupId&gt; &lt;artifactId&gt;barcode4j-light&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; 创建生成条形码的工具类，还是用字节流输出文件，不同的是 Code128Bean去描绘出条形码。在PrintTmOrder里面，去获取生成的文件，java画到纸上。 //第三行，条形码 String orderCode = printVo.getOrderCode(); String path = tmParameters.getPath();//参数路径 BarcodeUtil.generateFile(orderCode,path); //把图片画到上 try { File file=new File(path); if(!file.exists()){ file.mkdir(); } BufferedImage image = ImageIO.read(file); Integer x0 = tmParameters.getX(); Integer y0 = tmParameters.getY(); Integer width = tmParameters.getWidth(); Integer height = tmParameters.getHeight(); g2.drawImage(image,x0,y0,width,height,null); } catch (IOException e) { logger.error(\"获取二维码图像异常\",e); } 到此，java简单打印字符串，打印二维码、条形码图片完成。展示一下条形码：已经上传gitee，可以自行下载。","link":"/2020/03/28/Work/JavaPrint4/"},{"title":"SpringBoot的java打印票据-3","text":"配置打印xml文件并解析打印东西，先设置纸张大小，各种参数。若把数字直接填写到打印过程，之后的更改比较麻烦，这里配置一个xml文件，所有的参数都从这里取出打印。 1.构建printSettings.xml文件，放置于resources中。 &lt;print&gt; &lt;!-- 打印机设置 --&gt; &lt;choosePrint&gt;3&lt;/choosePrint&gt; &lt;!-- 打印任务名称 --&gt; &lt;printName&gt;PDF&lt;/printName&gt; &lt;!-- 打印机选择,为空时选择默认打印机 --&gt; &lt;defPrintName&gt;&lt;/defPrintName&gt; &lt;!-- true:配置生效,false:配置不生效 --&gt; &lt;isPrint&gt;true&lt;/isPrint&gt; &lt;!-- 二维码尺寸90*90 --&gt; &lt;qrcodeSize&gt;70&lt;/qrcodeSize&gt; &lt;!--存放二维码的基本地址--&gt; &lt;basePath&gt;G:\\JavaPrintQRCode\\&lt;/basePath&gt; &lt;!-- 纸张设置 --&gt; &lt;paper&gt; &lt;!-- 打印纸张设置paperWidth,paperHeight --&gt; &lt;paperWidth&gt;595&lt;/paperWidth&gt; &lt;paperHeight&gt;842&lt;/paperHeight&gt; &lt;!-- 打印区域设置x,y,width,height --&gt; &lt;x&gt;10&lt;/x&gt; &lt;y&gt;15&lt;/y&gt; &lt;width&gt;580&lt;/width&gt; &lt;height&gt;840&lt;/height&gt; &lt;/paper&gt; &lt;!--条形码参数--&gt; &lt;tmParameters&gt; &lt;paperWidth&gt;200&lt;/paperWidth&gt; &lt;paperHeight&gt;150&lt;/paperHeight&gt; &lt;useWidth&gt;180&lt;/useWidth&gt; &lt;useHeight&gt;100&lt;/useHeight&gt; &lt;useX&gt;5&lt;/useX&gt; &lt;useY&gt;10&lt;/useY&gt; &lt;x&gt;20&lt;/x&gt; &lt;y&gt;40&lt;/y&gt; &lt;width&gt;170&lt;/width&gt; &lt;height&gt;50&lt;/height&gt; &lt;path&gt;D:\\JavaPrintTmCode\\&lt;/path&gt; &lt;titleFontName&gt;宋体&lt;/titleFontName&gt; &lt;titleSize&gt;10&lt;/titleSize&gt; &lt;addressSize&gt;20&lt;/addressSize&gt; &lt;numberSize&gt;10&lt;/numberSize&gt; &lt;companyName&gt;玖陆物流&lt;/companyName&gt; &lt;tmPrintName&gt;Xprinter XP-365B&lt;/tmPrintName&gt; &lt;!--&lt;tmPrintName&gt;360&lt;/tmPrintName&gt;--&gt; &lt;/tmParameters&gt; &lt;!-- 打印数据参数设置 --&gt; &lt;dataset&gt; &lt;data x=\"5\" y=\"30\" name=\"startAddress\" cellWidth=\"\" cellHeight=\"\" font=\"宋体\" size=\"16\"/&gt; &lt;datas name=\"appGoodsOrder\" type=\"\"&gt; &lt;data x=\"110\" y=\"110\" name=\"goodsName\" /&gt; &lt;data x=\"205\" y=\"110\" name=\"goodsPkgs\" /&gt; &lt;data x=\"295\" y=\"110\" name=\"goodsPackage\" /&gt; &lt;/datas&gt; &lt;!--费用格式--&gt; &lt;datas name=\"appFeeOrder\" type=\"\"&gt; &lt;data x=\"70\" y=\"230\" name=\"feeText\" /&gt; &lt;/datas&gt; &lt;table x=\"\" y=\"\" width=\"\" height=\"\"&gt; &lt;tr width=\"\" height=\"\"&gt; &lt;td width=\"\" height=\"\" colspan=\"\" rowspan=\"\" &gt;&lt;/td&gt; &lt;td width=\"\" height=\"\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/dataset&gt; &lt;/print&gt; 设置好之后，到pom文件中按下alt + insert 引入maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;/dependency&gt; 让节点构成实体。这样方便我们在打印过程中取值。下面是我的实体结构，从最上层逐步往下。其中PrintSettings类是最上层。在加入注解时，可能会有重复的名称，我们需要加入 @XmlTransient注解，这样只在@XmlRootElement注解的实体中找寻有无重复，不管其他类的变量。展示一下最上层和其次顺序的类。 package com.cargo.order.settings; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import javax.xml.bind.annotation.*; /** *打印设置POJO * @since 2020/3/25 8:46 **/ @Data @AllArgsConstructor @NoArgsConstructor @XmlRootElement(name = \"print\") @XmlAccessorType(XmlAccessType.FIELD) public class PrintSettings { @XmlElement(name = \"choosePrint\") private String choosePrint; @XmlElement(name = \"printName\") private String printName; @XmlElement(name = \"isPrint\") private Boolean isPrint; @XmlElement(name = \"qrcodeSize\") private Integer qrcodeSize; @XmlElement(name = \"basePath\") private String basePath; @XmlElement(name = \"paper\") private Paper paper; @XmlElement(name = \"dataset\") private DataSet dataSet; @XmlElement(name = \"tmParameters\") private TmParameters tmParameters; public TmParameters getTmParameters() { return tmParameters; } public void setTmParameters(TmParameters tmParameters) { this.tmParameters = tmParameters; } public String getChoosePrint() { return choosePrint; } public void setChoosePrint(String choosePrint) { this.choosePrint = choosePrint; } public String getPrintName() { return printName; } public void setPrintName(String printName) { this.printName = printName; } public Boolean getPrint() { return isPrint; } public void setPrint(Boolean print) { isPrint = print; } public Integer getQrcodeSize() { return qrcodeSize; } public void setQrcodeSize(Integer qrcodeSize) { this.qrcodeSize = qrcodeSize; } public Paper getPaper() { return paper; } public void setPaper(Paper paper) { this.paper = paper; } public DataSet getDataSet() { return dataSet; } public void setDataSet(DataSet dataSet) { this.dataSet = dataSet; } public String getBasePath() { return basePath; } public void setBasePath(String basePath) { this.basePath = basePath; } } 然后展示一下Paper实体. package com.cargo.order.settings; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import javax.xml.bind.annotation.XmlAttribute; import javax.xml.bind.annotation.XmlElement; import javax.xml.bind.annotation.XmlRootElement; import javax.xml.bind.annotation.XmlTransient; @Data @AllArgsConstructor @NoArgsConstructor @XmlRootElement(name = \"paper\") public class Paper { @XmlElement(name = \"paperWidth\") private Integer paperWidth; @XmlElement(name = \"paperHeight\") private Integer paperHeight; @XmlElement(name = \"x\") private Integer x; @XmlElement(name = \"y\") private Integer y; @XmlElement(name = \"width\") private Integer width; @XmlElement(name = \"height\") private Integer height; @XmlTransient public Integer getPaperWidth() { return paperWidth; } public void setPaperWidth(Integer paperWidth) { this.paperWidth = paperWidth; } @XmlTransient public Integer getPaperHeight() { return paperHeight; } public void setPaperHeight(Integer paperHeight) { this.paperHeight = paperHeight; } @XmlTransient public Integer getX() { return x; } public void setX(Integer x) { this.x = x; } @XmlTransient public Integer getY() { return y; } public void setY(Integer y) { this.y = y; } @XmlTransient public Integer getWidth() { return width; } public void setWidth(Integer width) { this.width = width; } @XmlTransient public Integer getHeight() { return height; } public void setHeight(Integer height) { this.height = height; } } 在要用的地方直接静态代码块，加载一次，使用，比如： private static PrintSettings printSettings; static { try { //读取Resource目录下的XML文件 Resource resource = new ClassPathResource(\"printSettings.xml\"); //利用输入流获取XML文件内容 BufferedReader br = new BufferedReader(new InputStreamReader(resource.getInputStream(), \"UTF-8\")); StringBuffer buffer = new StringBuffer(); String line = \"\"; while ((line = br.readLine()) != null) { buffer.append(line); } br.close(); //XML转为JAVA对象 PrintSettings settings = (PrintSettings) XmlBuilder.xmlStrToObject(PrintSettings.class, buffer.toString()); printSettings = settings; }catch (Exception e){ logger.error(\"异常\",e); } } 到此xml文件配置好了，也可以使用。代码已上传到gitee","link":"/2020/03/27/Work/Javaprint3/"},{"title":"Js引入百度地图","text":"工作中有时需要根据项目需求引入地图进行展示数据，现在做一个超简单的引入。推荐百度api，全是中文解释，很方便。百度API* 引入百度js1.新建一个html页面，引入js &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"expires\" content=\"0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta content=\"width=device-width, initial-scale=1\" name=\"viewport\" /&gt; &lt;script type=\"text/javascript\" src=\"http://api.map.baidu.com/api?v=3.0&amp;ak=gYR4wlvCmPyZYq8ggttE3fkGuBC5sOUB\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/static/lib/jquery.liMarquee/jquery.liMarquee.js\"&gt;&lt;/script&gt; &lt;script&gt; (function(a,h,g,f,e,d,c,b){b=function(){d=h.createElement(g);c=h.getElementsByTagName(g)[0];d.src=e;d.charset=\"utf-8\";d.async=1;c.parentNode.insertBefore(d,c)};a[\"SeniverseWeatherWidgetObject\"]=f;a[f]||(a[f]=function(){(a[f].q=a[f].q||[]).push(arguments)});a[f].l=+new Date();if(a.attachEvent){a.attachEvent(\"onload\",b)}else{a.addEventListener(\"load\",b,false)}}(window,document,\"script\",\"SeniverseWeatherWidget\",\"/static/lib/xy.weather/widget2.bundle.js?t=\"+parseInt((new Date().getTime() / 100000000).toString(),10))); &lt;/script&gt; &lt;script src=\"js/TrackDisplayByBaidu.js\"&gt;&lt;/script&gt; &lt;title&gt;轨迹图&lt;/title&gt; &lt;style type=\"text/css\"&gt; .anchorBL{ display:none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"allmap\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 这样html准备好了。2.创建自定义的js文件 /** * 实时作业监控JS */ var map = null; var marker = null; $(function() { // 百度地图API功能 map = new BMap.Map(\"allmap\", { enableMapClick:false }); map.centerAndZoom(\"重庆\", 13); map.addControl(new BMap.MapTypeControl({ mapTypes:[ BMAP_NORMAL_MAP, BMAP_SATELLITE_MAP, BMAP_HYBRID_MAP ]} )); map.enableScrollWheelZoom(true); // 添加比例尺控件 map.addControl(new BMap.ScaleControl()); // 初始化图标 $('#allmap div.anchorBL').hide() $(\"#search_button\").linkbutton({ text:'搜索', iconCls:'icon-search', onClick:function () { //获取参数 map.clearOverlays(); $.ajax({ url:'json/comment.json', method: \"post\", dataType: \"json\", data: params, async: false, success: function (data) { $.each(data.rows,function (i,obj) { if(obj.start_longitude){ doLocate(obj.start_longitude,obj.start_latitude,obj); } if(obj.end_longitude){ doLocate(obj.end_longitude,obj.end_latitude,obj); } }); } }); } }); }); function doLocate(jd, wd,data) {//根据经纬度定位 var point = new BMap.Point(jd, wd); marker = new BMap.Marker(point); map.addOverlay(marker); marker.enableDragging(); //启用标注拖动 if(data){ var taskId = data.trailer_task_id; var distance = data.distance; var opts = { width: 210, // 信息窗口宽度 height: 125, // 信息窗口高度 title: \"&lt;a href='javascript:;' onclick=\\\"generateTrack('\"+taskId+\"','\"+distance+\"')\\\"&gt;对应站点生成轨迹&lt;/a&gt;\", // 信息窗口标题 enableMessage: true, //设置允许信息窗发送短息 message: \"\" }; var content = \"起始地:\"+ data.start_place+\"&lt;br&gt;目的地:\"+data.end_place+ \"&lt;br&gt;经度:\" + jd + \"&lt;br&gt;纬度:\" + wd; var infoWindow = new BMap.InfoWindow(content, opts); // 创建信息窗口对象 marker.addEventListener(\"click\", function() { map.openInfoWindow(infoWindow, point); //开启信息窗口 }); } } function generateTrack(taskId,distance){ console.info(taskId); // 查询人员行进轨迹--画线 $.ajax({ url : \"json/location.json\", method : \"post\", dataType : \"json\", async : false, success : function (data) { // 添加个人轨迹 var points = []; var rows = data.rows; $.each(rows, function (i, obj) { var currentTaksId = rows[i].taskId; if(currentTaksId == taskId){ $.each(rows[i].data,function (j,data) { var point = new BMap.Point(data.longitude,data.latitude); points.push(point); if(j == 0){ map.setCenter(point); } }); $(\"#driver_naem\").html(rows[i].driverName); } }); var sy = new BMap.Symbol(BMap_Symbol_SHAPE_BACKWARD_OPEN_ARROW, { scale: 0.6, strokeColor:'#fff', strokeWeight: '2', }); var icons = new BMap.IconSequence(sy, '10', '10'); var polyline =new BMap.Polyline(points, { enableEditing: false, enableClicking: true, icons:[icons], strokeWeight:'8', strokeOpacity: 0.8, strokeColor:\"#ff5c34\" }); map.addOverlay(polyline); var juli = 0; for (let i = 0; i &lt; points.length; i++) { if(i == points.length -1){ break; } juli += getDistance(points[i],points[i+1]); } $(\"#current_mileage\").html(distance+\"/km\"); $(\"#latest_mileage\").html((Math.round(juli/100)/10).toFixed(1)+\"/km\"); } }); } function getDistance(startPoint, endPoint) { return map.getDistance(startPoint ,endPoint); }","link":"/2020/04/19/Work/Js%E5%BC%95%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE/"},{"title":"Work/itextpdf导出数据","text":"itextpdf导出数据这是一个导出数据为pdf的demo。 1.Maven种添入依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itext-asian&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt; 2.创建pdf工具类 3.组装数据进行填充和样式设置 创建PdfUtil1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.cargo.trailer.orderManage.vo;import com.itextpdf.text.*;import com.itextpdf.text.pdf.BaseFont;import com.itextpdf.text.pdf.PdfPCell;import com.itextpdf.text.pdf.PdfPTable;import com.itextpdf.text.pdf.PdfWriter;import me.javy.helper.Helper;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.net.URLEncoder;import java.util.List;/***填充数据--以日期空一行，列种不同的字段颜色不同*/public class PdfUtil { public static void exportPdf(HttpServletRequest request, HttpServletResponse response, List&lt;List&lt;String&gt;&gt; lists, String fileName) throws IOException,DocumentException { // 告诉浏览器用什么软件可以打开此文件 response.setHeader(\"content-Type\", \"application/pdf\"); // 导出文件的默认名称 response.setHeader(\"Content-Disposition\",\"attachment;fileName=\" + URLEncoder.encode(fileName + \".pdf\", \"UTF-8\")); BaseFont baseFont = BaseFont.createFont(\"STSongStd-Light\", \"UniGB-UCS2-H\", BaseFont.EMBEDDED); // 自定义字体属性 com.itextpdf.text.Font font = new com.itextpdf.text.Font(baseFont, 8); com.itextpdf.text.Font titleFont = new com.itextpdf.text.Font(baseFont, 10); Document document = new Document(new RectangleReadOnly(842F,595F));//a4纸横向 PdfWriter.getInstance(document, response.getOutputStream()); document.open();//文本开始 if (lists.size() &gt; 0 &amp;&amp; lists != null) { for (int i = 0; i &lt; lists.size(); i++) { PdfPTable table = new PdfPTable(lists.get(i).size()); table.setWidthPercentage(100);//table100% PdfPCell cell = new PdfPCell(); if (i == 0) { if (lists.get(i).size() &gt; 0 &amp;&amp; lists.get(i) != null) { for (int j = 0; j &lt; lists.get(i).size(); j++) { Paragraph p=new Paragraph(lists.get(i).get(j), titleFont); p.setFont(titleFont); // 水平居中 cell.setHorizontalAlignment(Element.ALIGN_CENTER); cell.setPhrase(p); cell.setBackgroundColor(new BaseColor(204, 204, 204)); // 文档中加入该段落 table.addCell(cell); document.add(table); } } }else { if (lists.get(i).size() &gt; 0 &amp;&amp; lists.get(i) != null) { for (int j = 0; j &lt; lists.get(i).size(); j++) { if(\"N\".equals(lists.get(i).get(j))){//不同日期之间空格 Paragraph blankRow4 = new Paragraph(18f, \" \", font); document.add(blankRow4); break; }else { Paragraph p=new Paragraph(lists.get(i).get(j),font); p.setFont(font); // 设置段落居中，其中1为居中对齐，2为右对齐，3为左对齐 //给外派上颜色 String field = lists.get(i).get(j); if(\"外派\".equals(field)){ PdfPCell wpCell = new PdfPCell(); wpCell.setBackgroundColor(new BaseColor(60,179,113)); wpCell.setHorizontalAlignment(Element.ALIGN_CENTER); wpCell.setPhrase(p); table.addCell(wpCell); document.add(table); continue; }else if(Helper.isNotEmpty(field) &amp;&amp; j == 3){ PdfPCell wpCell = new PdfPCell(); wpCell.setBackgroundColor(new BaseColor(255,255,0)); wpCell.setHorizontalAlignment(Element.ALIGN_CENTER); wpCell.setPhrase(p); table.addCell(wpCell); document.add(table); continue; }else{ cell.setHorizontalAlignment(Element.ALIGN_CENTER); cell.setPhrase(p); table.addCell(cell); document.add(table); } } } } } } document.close(); } }} 组装数据 1.日期不同之间空一行。用order by date asc 查询数据。载这行和下一行比较，若不同，则增加一个List 一个元素为N，用于之后填充时判断。 2.列的不同数据显示不同颜色。创建PdfPCell 对象，设置样式。 大约这样：","link":"/2020/05/13/Work/itextpdf%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"nodeJs","slug":"nodeJs","link":"/tags/nodeJs/"}],"categories":[{"name":"WEB","slug":"WEB","link":"/categories/WEB/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"人生","slug":"人生","link":"/categories/%E4%BA%BA%E7%94%9F/"},{"name":"Life","slug":"Life","link":"/categories/Life/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/categories/SpringBoot/"},{"name":"JS","slug":"JS","link":"/categories/JS/"}]}