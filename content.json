{"pages":[{"title":"","text":"关于我大家好，我是山沉，这是我建的第一个博客。现在是java+微服务路上的行者，希望我们共同上路，一路前行。 我的站点 博客园：山沉 CSDN：山沉 思否：山沉 掘金：山沉","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"ie浏览器的加载js不了的问题","text":"2020年3月13日工作问题问题：在jsp页面，下有js文件没有加载出来，但是在f12下，刷新就加载出来了。 我打开的网页是360安全浏览器，内核设置为ie8，但是打开网页有一些js文件就是加载不出来，后来查询 得知。在ie8/9模式下，只能打开f12生效console方法。在ie6/7，根本没有这个方法。 解决： 1.直接一点，删除就可以了 2.用代码解决 if(window.console){ //一些console命令 console.info(&quot;gogo&quot;)； }这次的问题发生了，及时的解决，才能更好的锻炼自己。","link":"/2020/03/13/313-ie/"},{"title":"Postgresql导出数据字典","text":"这是在工作中，有时会遇到的问题，要求完善数据字典。这里是python导出Postgresql表的字典，仅供参考。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161import psycopg2import xlwtfrom datetime import datetimeimport os def getData(): conn = psycopg2.connect(database='数据库名', user='postgres', password='密码', host='127.0.0.1', port=5432) cur = conn.cursor() query = ''' SELECT d.relname AS relname, obj_description ( relfilenode, 'pg_class' ) AS tablename, attname AS field,CASE typname WHEN '_bpchar' THEN 'char' WHEN '_varchar' THEN 'varchar' WHEN '_date' THEN 'date' WHEN '_float8' THEN 'float8' WHEN '_int4' THEN 'int4' WHEN '_int8' THEN 'int8' WHEN '_interval' THEN 'interval' WHEN '_numeric' THEN 'numeric' WHEN '_float4' THEN 'float4' WHEN '_int2' THEN 'smallint' WHEN '_text' THEN 'text' WHEN '_time' THEN 'time' WHEN '_timestamp' THEN 'timestamp' WHEN '_timestamptz' THEN 'timestamptz' END AS TYPE, CASE typname WHEN '_bpchar' THEN atttypmod - 4 WHEN '_varchar' THEN atttypmod - 4 WHEN '_numeric' THEN ( atttypmod - 4 ) / 65536 ELSE attlen END AS LENGTH, CASE typname WHEN '_numeric' THEN ( atttypmod - 4 ) % 65536 ELSE 0 END AS xs,CASE WHEN b.attnotnull = 't' THEN '不能为空' ELSE'' END AS NOTNULL,CASE WHEN ( SELECT COUNT ( * ) FROM pg_constraint WHERE conrelid = b.attrelid AND conkey [ 1 ]= attnum AND contype = 'p' ) &gt; 0 THEN '主键' ELSE'' END AS zj ,col_description ( b.attrelid, b.attnum ) AS COMMENTFROM pg_stat_user_tables AS A, pg_class AS d, pg_tables AS P, pg_attribute AS b, pg_type AS CWHERE A.relid = b.attrelid AND b.attnum &gt; 0 AND b.atttypid = C.typelem AND substr( typname, 1, 1 ) = '_' AND P.tablename = d.relname AND d.relname = A.relname AND A.relname NOT LIKE'c%' AND A.relname NOT LIKE'S%'ORDER BY A.schemaname, A.relname,attnum ''' cur.execute(query) data = cur.fetchall() conn.commit() cur.close() conn.close() return data def queryDataToExcel(name): data = getData() myExcel = xlwt.Workbook('encoding=utf-8') # 查询二原数据采集量 sheet1 = myExcel.add_sheet(name, cell_overwrite_ok=True) sheet1.col(0).width = 150 * 20 sheet1.col(1).width = 150 * 20 sheet1.col(2).width = 150 * 20 sheet1.col(3).width = 150 * 20 sheet1.col(4).width = 150 * 20 sheet1.col(5).width = 150 * 20 sheet1.col(6).width = 150 * 20 sheet1.col(7).width = 150 * 20 sheet1.col(8).width = 150 * 20 sheet1.col(8).width = 350 * 20 #设置居中 a1 = xlwt.Alignment() a1.horz = 0x02 a1.vert = 0x01 style = xlwt.XFStyle() # 赋值style为XFStyle为初始化样式 style.alignment = a1 today = datetime.today() # 获取当前日期，得到一个datetime对象如：(2019, 7, 2, 23, 12, 23, 424000) today_date = datetime.date(today) # 将获取到的datetime对象仅取日期如：2019-7-2 items = ['数据表', '表名', '字段', '类型', '长度', '小数点', '是否为空', '是否为主键', '注释'] for col in range(len(items)): sheet1.write(0, col, items[col]) # 从data获取第一列数据，[(&quot;xxx&quot;,&quot;xxx&quot;),()] first_col = [] for i in range(len(data)): first_col.append(data[i][0]) print(&quot;first_col:&quot;, first_col) # 去掉重复的列数据，并顺序不变 nFirst_col = list(set(first_col)) nFirst_col.sort(key=first_col.index) print(&quot;nFirst_col:&quot;, nFirst_col) row = 1 for i in nFirst_col: count = first_col.count(i) # 计算重复的元素个数 mergeRow = row + count - 1 # 合并后的上行数， sheet1.write_merge(row, mergeRow, 0, 0, i, style) # 第一列 sheet1.write_merge(row, mergeRow, 1, 1, i, style) row = mergeRow + 1 # 从下一行开始写入 # 获取data[i]中的第二个元素，循环写入 for row in range(len(data)): for col in range(1, len(data[row])): sheet1.write(row + 1, col, data[row][col], style) fileName = name + '_' + str(today_date) + '.xls' rootPath = os.path.dirname(os.path.abspath(_file_))+'\\\\' print(rootPath) flag = os.path.exists(rootPath+fileName) if flag: os.remove(rootPath+fileName) myExcel.save(fileName) else: myExcel.save(fileName) # 以传递的name+当前日期作为excel名称保存 if __name__ == '__main__': print(&quot;这是从postgresql中导出excel的demo----&quot;) queryDataToExcel(&quot;数据表&quot;) 这里我用的是xlwt，没用openpyxl操作","link":"/2020/03/07/ExportTable/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/06/hello-world/"},{"title":"hexo+icarus搭建的第一个博客","text":"博客的搭建过程中，才发现自己会的东西挺少。今后会继续学习，持之以恒，参考了的一些资料，总算搭建了一个hexo+icarus实现的博客。 所需内容 github账户一个 nodejs安装(之后在安装hexo等) git for windows 0.申请一个github账户注册账户，完成之后生成一个GitHub的 ID.github.io的仓库。这个在之后上传静态资源，可以作为默认网址访问博客。 1.nodejs安装这里不过多的叙述，或者在网上找资料，普通的安装。 2.hexo+icarus搭建博客&emsp;这里推荐小明同学的博客，丰富的记录了hexo搭建博客的所需事项。当时域名的绑定与配置没有搞清楚，后来配置域名时，才知道在国内注册的域名要备案，后来又去备案，结果没有备案，照下面这样做，也能访问。(最好备案，各个网站的app备案更快.) 3.配置华为云域名 在项目的source目录下建一个没有后缀的文件-CNAME，里面写入www.xxx.xx你的域名。 123hexo cleanhexo generatehexo deploy 只要过2到3分中即可用域名访问了。OK！","link":"/2020/03/07/hexo%E6%90%AD%E5%BB%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"},{"title":"nodejs启动服务失败","text":"nodejs启动服务过程中难免遇到一些问题，此次我就遇到了node-sass安装后环境发生变化的问题。 1.第一次提示This usually happens because your environment has changed since running npm install百度说是node-sass安装后环境发生变化。需要重新编译或安装node-sass 解决 1.在项目根路径打开管理员模式的cmd 2 npm rebuild node-sass 2.1 提示Cannot download “https://github.com/sass/node-sass/releases/download/v4.13.1/win32-x64-72_binding.node&quot;: 3.设置淘宝下载 npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ ok,启动node服务成功","link":"/2020/03/07/nodejs/"},{"title":"Python导出SqlServer数据字典","text":"定义三个方法1.定义一个获取数据的getData()方法2.定义一个导出excel表的方法exportSqlServer()3.定义一个获取类型typeof()的方法，用作查询出来的数据被识别 下面直接展示代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147from datetime import datetimeimport osimport pymssql as pymssqlimport xlwtdef getData(): connect= pymssql.connect(host, 'sa', 密码, 数据库名); cur = connect.cursor(); query = ''' SELECT tableName = D.name , # 我合并单元格是按照这里的表的重复合并的，若用case whern end 结构，则不能合并，会出错 tableIntroduce = isnull(F.value,''), sort = A.colorder, fieldName = A.name, catogary = B.name, bytes = A.Length, lengths = COLUMNPROPERTY(A.id,A.name,'PRECISION'), scales = isnull(COLUMNPROPERTY(A.id,A.name,'Scale'),0), isOrNotNull = Case When A.isnullable=1 Then '√'Else '' End, primarays = Case When exists(SELECT 1 FROM sysobjects Where xtype='PK' and parent_obj=A.id and name in ( SELECT name FROM sysindexes WHERE indid in( SELECT indid FROM sysindexkeys WHERE id = A.id AND colid=A.colid))) then '√' else '' end, defauts = isnull(E.Text,''), annotations = isnull(G.[value],'') FROM syscolumns A Left Join systypes B On A.xusertype=B.xusertype Inner Join sysobjects D On A.id=D.id and D.xtype='U' and D.name&lt;&gt;'dtproperties' Left Join syscomments E on A.cdefault=E.id Left Join sys.extended_properties G on A.id=G.major_id and A.colid=G.minor_id Left Join sys.extended_properties F On D.id=F.major_id and F.minor_id=0 --where d.name='OrderInfo' --如果只查询指定表,加上此条件 Order By A.id,A.colorder''' cur.execute(query) data = cur.fetchall() # 元组类型 return datadef exportExcel(name): data = getData() myExcel = xlwt.Workbook('encoding=utf-8') # 定义表的宽 sheet1 = myExcel.add_sheet(name, cell_overwrite_ok=True) sheet1.col(0).width = 300 * 20 sheet1.col(1).width = 400 * 20 sheet1.col(2).width = 100 * 20 sheet1.col(3).width = 300 * 20 sheet1.col(4).width = 256 * 20 sheet1.col(5).width = 180 * 20 sheet1.col(6).width = 180 * 20 sheet1.col(7).width = 100 * 20 sheet1.col(8).width = 100 * 20 sheet1.col(9).width = 100 * 20 sheet1.col(10).width = 180 * 20 sheet1.col(11).width = 800 * 20 # 设置居中 a1 = xlwt.Alignment() a1.horz = 0x02 a1.vert = 0x01 style = xlwt.XFStyle() # 赋值style为XFStyle为初始化样式 style.alignment = a1 today = datetime.today() # 获取当前日期，得到一个datetime对象如：(2019, 7, 2, 23, 12, 23, 424000) today_date = datetime.date(today) # 将获取到的datetime对象仅取日期如：2019-7-2 items = ['数据表', '表名', '字段序号', '字段', '类型', '占用字节数', '长度', '小数点', '是否为空', '是否为主键', '默认值','注释'] for col in range(len(items)): sheet1.write(0, col, items[col]) # 合并第二列的name,从content获取第一列数据，[(&quot;Choleen&quot;,&quot;xxx&quot;),()] first_col = [] for i in range(len(data)): first_col.append(data[i][0]) print(&quot;first_col:&quot;, first_col) # 去掉重复的列数据，并顺序不变 nFirst_col = list(set(first_col)) nFirst_col.sort(key=first_col.index) print(&quot;nFirst_col:&quot;, nFirst_col) row = 1 for i in nFirst_col: count = first_col.count(i) # 计算重复的元素个数 mergeRow = row + count - 1 # 合并后的上行数， sheet1.write_merge(row, mergeRow, 0, 0, i, style) # 第一列 sheet1.write_merge(row, mergeRow, 1, 1, i, style) row = mergeRow + 1 # 从下一行开始写入 # 获取data[i]中的第二个元素，循环写入 for row in range(len(data)): for col in range(1, len(data[row])): result = data[row][col] str = typeof(result) # 获取类型 if str == None: # 不能识别的类型，需要转换 result = result.decode('utf-8') sheet1.write(row + 1, col, result, style) fileName = name + '.xls' rootPath = os.path.dirname(os.path.abspath('ExportSqlServer.py')) + '\\\\' print(rootPath) flag = os.path.exists(rootPath + fileName) if flag: os.remove(rootPath + fileName) myExcel.save(fileName) else: myExcel.save(fileName) def typeof(variate): type = None if isinstance(variate, int): type = &quot;int&quot; elif isinstance(variate, str): type = &quot;str&quot; elif isinstance(variate, float): type = &quot;float&quot; elif isinstance(variate, list): type = &quot;list&quot; elif isinstance(variate, tuple): type = &quot;tuple&quot; elif isinstance(variate, dict): type = &quot;dict&quot; elif isinstance(variate, set): type = &quot;set&quot; return typeif __name__ == '__main__': print(&quot;这是sqlServer导出的数据字典&quot;); # response = chardet.detect(b'\\xe7\\x94\\xa8\\xe6\\x88\\xb7\\xe8\\xa1\\xa8') # print(response) exportExcel(&quot;user表&quot;) 在编写代码过程中出现了，中文乱码。python3会自动转换未unicode，我们来看下转换过程： 1234567 UTF-8/GBK --》 decode 解码 --》 Unicode Unicode --》 encode 编码 --》 GBK / UTF-8 ``` 这里的代码是Unicode,要转换成明文，就需要decode方法，只能是unicode的格式才能，若是int，str类型则会报错 ```angular2html明文 -- encode --》Unicode--》gbk，utf-8明文 《-- decode -- Unicode 《-- gbk，utf-8 so，这样就可以了。完成。","link":"/2020/03/17/Python/Python%E5%AF%BC%E5%87%BAsqlServer%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8/"},{"title":"springboot的java打印票据","text":"Java打印的几个步骤 1构建springboot框架 2引入log日志 3构建java打印xml文件 4解析xml配置文件 5java打印 由于需要，现在要实现一个java打印的程序。我们开始第一步构建springboot项目。 第一步打开idea，new 一个Project，选择Spring initializr 初始化一个springboot项目。在pom文件中按下alt + insert 选择Dependency使用idea的引入maven依赖。如下： &lt;!--基础依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--httpClient连接--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--gogle的Zxing生成二维码--&gt; &lt;!-- https://mvnrepository.com/artifact/com.google.zxing/core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.google.zxing/javase --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--判断非空等的工具依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;me.javy&lt;/groupId&gt; &lt;artifactId&gt;javy-helper&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--使用pojo解析xml文件所用--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;/dependency&gt; 下面是我的类结构图：配置httpClient 1.httpClient连接可以远程访问服务器，获取数据，有时需要。所以这里也配一下。下面我们进行httpClient配置。在config包下建一个httpClient和httpCLientService，一个是构建对象一个是连接服务。在properties中写入httpclient的基础配置： #http配置服务 #最大连接数 http.maxTotal = 100 #并发数 http.defaultMaxPerRoute = 20 #创建连接的最长时间 http.connectTimeout=1000 #从连接池中获取到连接的最长时间 http.connectionRequestTimeout=500 #数据传输的最长时间 http.socketTimeout=10000 #提交请求前测试连接是否可用 http.staleConnectionCheckEnabled=true 2.在httpClient往容器中注入Bean属性，采用注解@Value来实现如下： @Configuration public class HttpClient { @Value(&quot;${http.maxTotal:1}&quot;) private Integer maxTotal; @Value(&quot;${http.defaultMaxPerRoute:1}&quot;) private Integer defaultMaxPerRoute; @Value(&quot;${http.connectTimeout:1}&quot;) private Integer connectTimeout; @Value(&quot;${http.connectionRequestTimeout:1}&quot;) private Integer connectionRequestTimeout; @Value(&quot;${http.socketTimeout:1}&quot;) private Integer socketTimeout; @Value(&quot;${http.staleConnectionCheckEnabled:true}&quot;) private boolean staleConnectionCheckEnabled; } 1.下面我们首先实列化一个连接池管理器，设置最大连接数，并发连接数。 @Bean(name = &quot;httpClientConnectionManager&quot;) public PoolingHttpClientConnectionManager getHttpClientConnectionManager(){ PoolingHttpClientConnectionManager httpClientConnectionManager = new PoolingHttpClientConnectionManager(); //最大连接数 httpClientConnectionManager.setMaxTotal(maxTotal); //并发数 httpClientConnectionManager.setDefaultMaxPerRoute(defaultMaxPerRoute); return httpClientConnectionManager; } 2.实列化连接池，设置连接池管理器。我们需要用到spring的@Qualifier，其意为合格者，用于区分注解实例，参数名为我们的连接池管理器注解名称。 @Bean(name = &quot;httpClientBuilder&quot;) public HttpClientBuilder getHttpClientBuilder(@Qualifier(&quot;httpClientConnectionManager&quot;)PoolingHttpClientConnectionManager httpClientConnectionManager){ //HttpClientBuilder中的构造方法被protected修饰，所以这里不能直接使用new来实例化一个HttpClientBuilder，可以使用HttpClientBuilder提供的静态方法create()来获取HttpClientBuilder对象 HttpClientBuilder httpClientBuilder = HttpClientBuilder.create(); httpClientBuilder.setConnectionManager(httpClientConnectionManager); return httpClientBuilder; } 3.注入连接池，获取client对象 @Bean public CloseableHttpClient getCloseableHttpClient(@Qualifier(&quot;httpClientBuilder&quot;) HttpClientBuilder httpClientBuilder){ return httpClientBuilder.build(); } 4.Builder是requestConfig中的一个内部类，通过requestConfig的custom方法获取builder的对象，设置builder的连接信息。 @Bean(name = &quot;builder&quot;) public RequestConfig.Builder getBuilder(){ RequestConfig.Builder builder = RequestConfig.custom(); return builder.setConnectTimeout(connectTimeout)//创建连接的最长时间 .setConnectionRequestTimeout(connectionRequestTimeout)//从连接池中获取的连接最长时间 .setSocketTimeout(socketTimeout)//数据传输的最长时间 .setStaleConnectionCheckEnabled(staleConnectionCheckEnabled);//提交请求前测试连接是否可用 } 5.用builder构建一个requestConfig对象 @Bean public RequestConfig getRequestConfig(@Qualifier(&quot;builder&quot;) RequestConfig.Builder builder){ return builder.build(); } 到此httpclient基础信息初始化配置完成。","link":"/2020/03/25/Work/JavaPrint/"},{"title":"今天复工，维护好累","text":"维护今天的工作&emsp;今天是我第一次正式维护工作，深知不易。代码可能没有几行，但大多数是在找前人写代码的漏洞，当然是客户给我们找到的。找寻bug很费劲，还原bug更费劲。我大量的时间在跟客户交流，没有几行代码输出，有很大一部分的原因是眉毛胡子一把抓，没有分清主次，搞得很疲惫。&emsp;提高自己的技术，还是重中之重，没有比自己肚子里有货更重要，今天开始学习松哥的springboot系列教程，希望自己可以得到提高。 如何提高自己&emsp;尽量多学习一点。尽量不气馁。尽量跟进时局。今天学习一点markdown的知识： 123半方大的空白&amp;ensp;或&amp;#8194;全方大的空白&amp;emsp;或&amp;#8195;不断行的空白格&amp;nbsp;或&amp;#160;","link":"/2020/03/16/Life/2020%E5%B9%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%85%AC%E5%8F%B8%E4%B8%8A%E7%8F%AD/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"nodeJs","slug":"nodeJs","link":"/tags/nodeJs/"}],"categories":[{"name":"WEB","slug":"WEB","link":"/categories/WEB/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"人生","slug":"人生","link":"/categories/%E4%BA%BA%E7%94%9F/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/categories/SpringBoot/"},{"name":"Life","slug":"Life","link":"/categories/Life/"}]}